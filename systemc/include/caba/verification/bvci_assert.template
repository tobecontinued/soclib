/* -*- c++ -*-
 *
 * SOCLIB_LGPL_HEADER_BEGIN
 * 
 * This file is part of SoCLib, GNU LGPLv2.1.
 * 
 * SoCLib is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation; version 2.1 of the License.
 * 
 * SoCLib is distributed observedSignals the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with SoCLib; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * SOCLIB_LGPL_HEADER_END
 *
 * Copyright (c) CEA
 *
 * Authors: Franck Vedrine <franck.vedrine@cea.fr>, 2008
 */

#ifndef SOCLIB_CABA_PVDC_BASIC_ASSERTTEMPLATE
#define SOCLIB_CABA_PVDC_BASIC_ASSERTTEMPLATE

#include "caba/verification/bvci_assert.h"

namespace soclib { namespace caba {

template <typename vci_param>
void
BasicVciAssert<vci_param>::testHandshake() { // see p 41, 42, verified on the waveforms
   switch (sRequestState) {
      case SIdle:
         if (observedSignals.cmdval) {
            acquireRequestCell();
            if (observedSignals.cmdack)
               sRequestState = SSync;
            else
               sRequestState = SValid;
         }
         else if (observedSignals.cmdack)
            sRequestState = SDefault_Ack;
         break;
      case SValid:
         assume(observedSignals.cmdval);
         assume((observedSignals.address == addressPrevious) && (observedSignals.be == bePrevious)
            && (observedSignals.cfixed == cfixedPrevious) && (observedSignals.clen == clenPrevious)
            && (observedSignals.cmd == cmdPrevious) && (observedSignals.contig == contigPrevious)
            && (observedSignals.wdata == wdataPrevious) && (observedSignals.eop == eopPrevious)
            && (observedSignals.cons == consPrevious) && (observedSignals.plen == plenPrevious)
            && (observedSignals.wrap == wrapPrevious));
         if (observedSignals.cmdack)
            sRequestState = SSync;
         break;
      case SDefault_Ack:
         assume(observedSignals.cmdack);
         if (observedSignals.cmdval) {
            acquireRequestCell();
            sRequestState = SSync;
         };
         break;
      case SSync:
         if (!observedSignals.cmdval) {
            if (!observedSignals.cmdack)
               sRequestState = SIdle;
            else
               sRequestState = SDefault_Ack;
         }
         else {
            acquireRequestCell();
            if (!observedSignals.cmdack)
               sRequestState = SValid;
         };
         break;
   };
 
   switch (sResponseState) {
      case SIdle:
         if (observedSignals.rspval) {
            acquireResponseCell();
            if (observedSignals.rspack)
               sResponseState = SSync;
            else
               sResponseState = SValid;
         }
         else if (observedSignals.rspack)
            sResponseState = SDefault_Ack;
         break;
      case SValid:
         assume(observedSignals.rspval);
         assume((observedSignals.rdata == rdataPrevious) && (observedSignals.reop == reopPrevious)
            && (observedSignals.rerror == rerrorPrevious));
         if (observedSignals.rspack)
            sResponseState = SSync;
         break;
      case SDefault_Ack:
         assume(observedSignals.rspack);
         if (observedSignals.rspval) {
            acquireResponseCell();
            sResponseState = SSync;
         };
         break;
      case SSync:
         if (!observedSignals.rspval) {
            if (!observedSignals.rspack)
               sResponseState = SIdle;
            else
               sResponseState = SDefault_Ack;
         }
         else {
            acquireResponseCell();
            if (!observedSignals.rspack)
               sResponseState = SValid;
         };
         break;
   };
}

template <typename vci_param>
void
BasicVciAssert<vci_param>::LockedAddress::add(typename vci_param::addr_t aAddress) {
  AddressInterval aiInterval(aAddress);
   typename std::set<AddressInterval>::iterator iter = saiAddresses.find(aiInterval);
   if (iter == saiAddresses.end())
      saiAddresses.insert(iter, aiInterval);
   else {
      AddressInterval& aiCurrent = const_cast<AddressInterval&>(*iter);
      aiCurrent.merge(aiInterval);
      ++iter;
      if (iter != saiAddresses.end() && (aiCurrent == *iter))
         saiAddresses.erase(iter);
      iter = saiAddresses.find(aiInterval);
      if (&*iter == &aiCurrent) {
         if (iter != saiAddresses.begin()) {
            --iter;
            if (aiCurrent == *iter)
               saiAddresses.erase(iter);
         };
      }
      else {
         if (aiCurrent == *iter)
            saiAddresses.erase(iter);
      };   
   };
}

template <typename vci_param>
void
BasicVciAssert<vci_param>::LockedAddress::add(typename vci_param::addr_t aAddress, int plen) {
   AddressInterval aiInterval(aAddress, plen);
   typename std::set<AddressInterval>::iterator iter = saiAddresses.find(aiInterval);
   if (iter == saiAddresses.end())
      saiAddresses.insert(iter, aiInterval);
   else {
      AddressInterval& aiCurrent = const_cast<AddressInterval&>(*iter);
      aiCurrent.merge(aiInterval);
      ++iter;
      if (iter != saiAddresses.end() && (aiCurrent == *iter))
         saiAddresses.erase(iter);
      iter = saiAddresses.find(aiInterval);
      if (&*iter == &aiCurrent) {
         if (iter != saiAddresses.begin()) {
            --iter;
            if (aiCurrent == *iter)
               saiAddresses.erase(iter);
         };
      }
      else {
         if (aiCurrent == *iter)
            saiAddresses.erase(iter);
      };   
   };
}

template <typename vci_param>
void
BasicVciAssert<vci_param>::LockedAddress::remove(typename vci_param::addr_t aAddress) {
   AddressInterval aiInterval(aAddress);
   typename std::set<AddressInterval>::iterator iter = saiAddresses.find(aiInterval);
   if (iter != saiAddresses.end()) {
      AddressInterval* paiOther = NULL;
      bool fExtern = false;
      bool fDelete = const_cast<AddressInterval&>(*iter).remove(aiInterval, paiOther, fExtern);
      if (fDelete)
         saiAddresses.erase(iter);
      else if (paiOther) {
         saiAddresses.insert(iter, *paiOther);
         delete paiOther;
      };
   };
}

template <typename vci_param>
void
BasicVciAssert<vci_param>::LockedAddress::remove(typename vci_param::addr_t aAddress, int plen) {
   AddressInterval aiInterval(aAddress, plen);
   typename std::set<AddressInterval>::iterator iter = saiAddresses.find(aiInterval);
   if (iter != saiAddresses.end()) {
      AddressInterval* paiOther = NULL;
      bool fExtern = false;
      bool fDelete = const_cast<AddressInterval&>(*iter).remove(aiInterval, paiOther, fExtern);
      if (fDelete)
         saiAddresses.erase(iter);
      else if (paiOther) {
         saiAddresses.insert(iter, *paiOther);
         delete paiOther;
      };
   };
}

template <typename vci_param>
void
BasicVciAssert<vci_param>::acquireRequestCell() {
   if (uRequestCells == 0) {
      if (packetClen > 0) {
         ++packetClen;
         assume(observedSignals.clen == packetClen && packetCmd == observedSignals.cmd && packetCfixed == observedSignals.cfixed);
         --packetClen;
         if (packetCfixed)
            assume(packetContig == observedSignals.contig && packetWrap == observedSignals.wrap
                  && packetCons == observedSignals.cons && packetPlen == observedSignals.plen);
      }
      else {
         packetClen = observedSignals.clen;
         ++packetClen;
         packetCmd = observedSignals.cmd;
         packetCfixed = observedSignals.cfixed;
      };
      --packetClen;
      packetAddress = observedSignals.address;
      packetPlen = observedSignals.plen;
      packetContig = observedSignals.contig;
      packetWrap = observedSignals.wrap;
      assume(!packetWrap || (packetContig && ((packetPlen-1 & packetPlen) == 0)));
      packetCons = observedSignals.cons;
      plPendingPackets.add(Packet(observedSignals));
      if (packetCmd == 3) { // Locked read
         if (packetContig)
            laLockedAddresses.add(packetAddress, packetPlen);
         else
            laLockedAddresses.add(packetAddress);
      };
   }
   else {
      assume(packetClen == observedSignals.clen && packetCmd == observedSignals.cmd && packetPlen == observedSignals.plen);
      if (packetCons) {
         assume(packetCfixed == observedSignals.cfixed && packetAddress == observedSignals.address
            && packetContig == observedSignals.contig && packetWrap == observedSignals.wrap && packetCons == observedSignals.cons);
      }
      else if (packetContig) {
         packetAddress += vci_param::B; // cell_size()
         if (packetWrap && (uRequestCells > packetPlen))
            packetAddress -= packetPlen*vci_param::B;
         assume(packetAddress == observedSignals.address);
      };
   };
   ++uRequestCells;
   ++plPendingPackets.last().length();
   if (observedSignals.eop) {
      assume(!packetPlen || packetPlen == uRequestCells);
      uRequestCells = 0;
      packetAddress = 0;
   };
}

template <typename vci_param>
void
BasicVciAssert<vci_param>::acquireResponseCell() {
   if (uResponseCells == 0) {
      assume(plPendingPackets.count() > 0);
      const Packet& packet = plPendingPackets.last();
      if (packet.cmd == 2) { // Write
         if (packet.contig)
            laLockedAddresses.remove(packet.address, packet.plen);
         else
            laLockedAddresses.remove(packet.address);
      };
   };
   ++uResponseCells;
   --plPendingPackets.last().length();
   if (observedSignals.reop) {
      assume(plPendingPackets.last().length() == 0);
      plPendingPackets.pop();
      uResponseCells = 0;
   };
}

}} // end of namespace soclib::caba

#endif // SOCLIB_CABA_PVDC_BASIC_ASSERTTEMPLATE

