
===========
Arith stuff
===========

We'll assume

 * a, b any integer

 * c is an input carry (0 or 1)

Carry out
=========

Carry calculation for a+b+c could be:

((uint64_t)a+(uint64_t)b+(uint64_t)c)>>32

but we can avoid 64 bits:

We have carry if result wraps. It does if unsigned sum has its result
less than any of its operands, ie if  (a+b) < a  or  (a+b) < b.

With a carry input, this is still true, but we must handle cases when
carry input makes the result wrap, which means  (a+b) = 0xffffffff
and (a+b+c) = 0.  This can also be checked for with a simple
statement: (a+b+c) < c.


Overflow
========

With an addition, we have:

      c32 c31 c30 .... c1  c0  with c0 = carry in = c
 +        a31 a30 .... a1  a0
 +        b31 b30 .... b1  b0
 ----------------------------
 =    r32 r31 r30 .... r1  r0

Overflow could have been

   ov = c32 xor c31

but it is also when operands are both the same sign (a31 == b31) and
result is another sign than both operands (b31 != r31) or, at your
choice, (a31 != r31).

   (a31 == b31) = not (a31 xor b31)
   (b31 != r31) = (b31 xor r31)

   ov = (b31 xor r31) and not (a31 xor b31)

therefore

   ov = (b31 xor (a+b+c)31) and not (a31 xor b31)

factoring out all those 31s, and in c syntax, this is:

   ov = ((b^(a+b+c))&~(a^b))>>31;
