/* -*- c++ -*-
*
* SOCLIB_LGPL_HEADER_BEGIN
*
* This file is part of SoCLib, GNU LGPLv2.1.
*
* SoCLib is free software; you can redistribute it and/or modify it
* under the terms of the GNU Lesser General Public License as published
* by the Free Software Foundation; version 2.1 of the License.
*
* SoCLib is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the cabaied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public
* License along with SoCLib; if not, write to the Free Software
* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
* 02110-1301 USA
*
* SOCLIB_LGPL_HEADER_END
*
* Copyright (c) Lab-sticc, file generated by GAUT(Version 2.4 February 2009)
*
*
*/
#include <stdlib.h>
#include <iostream>
#include "base_module.h"
#include "mwmr_fir16.h"
#include "soclib_endian.h"

namespace soclib { namespace caba {

#define tmpl(x) template <typename vci_param> x Mwmr_fir16<vci_param>

/* Constructor */
tmpl(/**/)::Mwmr_fir16(sc_module_name insname, std::vector<int> coeffs)
	:soclib::caba::BaseModule(insname),	
	p_clk("clk"),
	p_resetn("resetn"),
	p_to_ctrl("p_to_ctrl"),
	p_from_ctrl("p_from_ctrl")
{
	SC_METHOD(transition);
	dont_initialize();
	sensitive << p_clk.pos();
	SC_METHOD(genMoore);
	dont_initialize();
	sensitive << p_clk.neg();	
	r_status.done = false;
	r_status.output_available = false;
	m_state_cycle = S0;
	m_wait_IO = false;
	/* constant */
	m_CoeffsLPAREN0RPAREN = coeffs[15]; // 98;
	m_CoeffsLPAREN1RPAREN = coeffs[14]; // -39;
	m_CoeffsLPAREN2RPAREN = coeffs[13]; // -327;
	m_CoeffsLPAREN3RPAREN = coeffs[12]; // 439;
	m_CoeffsLPAREN4RPAREN = coeffs[11]; // 950;
	m_CoeffsLPAREN5RPAREN = coeffs[10]; // -2097;
	m_CoeffsLPAREN6RPAREN = coeffs[9]; // -1674;
	m_CoeffsLPAREN7RPAREN = coeffs[8]; // 9883;
	m_CoeffsLPAREN8RPAREN = coeffs[7]; // 9883;
	m_CoeffsLPAREN9RPAREN = coeffs[6]; // -1674;
	m_CoeffsLPAREN10RPAREN = coeffs[5]; // -2097;
	m_CoeffsLPAREN11RPAREN = coeffs[4]; // 950;
	m_CoeffsLPAREN12RPAREN = coeffs[3]; // 439;
	m_CoeffsLPAREN13RPAREN = coeffs[2]; // -327;
	m_CoeffsLPAREN14RPAREN = coeffs[1]; // -39;
	m_const_98 = coeffs[0]; // 98;
}

/* predefined or user defined  operation */

/* Transition function */
/* Evaluated on Positive Clock Edge */
tmpl(void)::transition()
{
	if (p_resetn.read() == false)
	{		
		r_status.done = false;
		r_status.output_available = false;
		m_state_cycle = S0;
		m_wait_IO = false;
		/* variable */
		m_fir16_1680 = 0;
		m_fir16_16800001 = 0;
		m_fir16_16800002 = 0;
		m_fir16_16800003 = 0;
		m_fir16_16800004 = 0;
		m_fir16_16800005 = 0;
		m_fir16_16800006 = 0;
		m_fir16_16800007 = 0;
		m_fir16_16800008 = 0;
		m_fir16_16800009 = 0;
		m_fir16_16800010 = 0;
		m_fir16_16800011 = 0;
		m_fir16_16800012 = 0;
		m_fir16_16800013 = 0;
		m_fir16_16800014 = 0;
		m_ValeursLPAREN10RPAREN = 0;
		m_ValeursLPAREN11RPAREN = 0;
		m_ValeursLPAREN12RPAREN = 0;
		m_ValeursLPAREN13RPAREN = 0;
		m_ValeursLPAREN14RPAREN = 0;
		m_ValeursLPAREN15RPAREN = 0;
		m_ValeursLPAREN1RPAREN = 0;
		m_ValeursLPAREN2RPAREN = 0;
		m_ValeursLPAREN3RPAREN = 0;
		m_ValeursLPAREN4RPAREN = 0;
		m_ValeursLPAREN5RPAREN = 0;
		m_ValeursLPAREN6RPAREN = 0;
		m_ValeursLPAREN7RPAREN = 0;
		m_ValeursLPAREN8RPAREN = 0;
		m_ValeursLPAREN9RPAREN = 0;
		m_temporaire = 0;
		m_temporaire0001 = 0;
		m_temporaire0002 = 0;
		m_temporaire0003 = 0;
		m_temporaire0004 = 0;
		m_temporaire0005 = 0;
		m_temporaire0006 = 0;
		m_temporaire0007 = 0;
		m_temporaire0008 = 0;
		m_temporaire0009 = 0;
		m_temporaire0010 = 0;
		m_temporaire0011 = 0;
		m_temporaire0012 = 0;
		m_temporaire0013 = 0;
		m_temporaire0014 = 0;
		/* output */
		m_data_out = 0;
		return;
	}	
	switch (m_state_cycle) {
		case S0:
			if (p_from_ctrl.rok.read())
			{
				sc_int<32> buffer = le_to_machine((uint32_t)p_from_ctrl.data);
				m_data_in = buffer;
				m_wait_IO = false;
			}
			else m_wait_IO = true;
			if (!m_wait_IO) m_state_cycle=S1;
		break;
		case S1:
			m_state_cycle=S2;
		break;
		case S2:
			m_temporaire = m_data_in * m_const_98;
			m_state_cycle=S3;
		break;
		case S3:
			m_fir16_1680 = m_ValeursLPAREN1RPAREN * m_CoeffsLPAREN14RPAREN;			
			m_state_cycle=S4;
		break;
		case S4:
			m_fir16_16800001 = m_CoeffsLPAREN13RPAREN * m_ValeursLPAREN2RPAREN;
			m_state_cycle=S5;
		break;
		case S5:
			m_temporaire0001 = m_fir16_16800001 + m_fir16_1680;
			m_fir16_16800002 = m_CoeffsLPAREN12RPAREN * m_ValeursLPAREN3RPAREN;
			m_state_cycle=S6;
		break;
		case S6:
			m_temporaire0002 = m_temporaire0001 + m_fir16_16800002;
			m_fir16_16800003 = m_CoeffsLPAREN11RPAREN * m_ValeursLPAREN4RPAREN;
			m_state_cycle=S7;
		break;
		case S7:
			m_temporaire0003 = m_temporaire0002 + m_fir16_16800003;
			m_fir16_16800004 = m_CoeffsLPAREN10RPAREN * m_ValeursLPAREN5RPAREN;
			m_state_cycle=S8;
		break;
		case S8:
			m_temporaire0004 = m_temporaire0003 + m_fir16_16800004;
			m_fir16_16800005 = m_CoeffsLPAREN9RPAREN * m_ValeursLPAREN6RPAREN;
			m_state_cycle=S9;
		break;
		case S9:
			m_temporaire0005 = m_temporaire0004 + m_fir16_16800005;
			m_fir16_16800006 = m_CoeffsLPAREN8RPAREN * m_ValeursLPAREN7RPAREN;
			m_state_cycle=S10;
		break;
		case S10:
			m_temporaire0006 = m_temporaire0005 + m_fir16_16800006;
			m_fir16_16800007 = m_CoeffsLPAREN7RPAREN * m_ValeursLPAREN8RPAREN;
			m_state_cycle=S11;
		break;
		case S11:
			m_temporaire0007 = m_temporaire0006 + m_fir16_16800007;
			m_fir16_16800008 = m_ValeursLPAREN9RPAREN * m_CoeffsLPAREN6RPAREN;
			m_state_cycle=S12;
		break;
		case S12:
			m_fir16_16800009 = m_CoeffsLPAREN5RPAREN * m_ValeursLPAREN10RPAREN;
			m_temporaire0008 = m_temporaire0007 + m_fir16_16800008;
			m_state_cycle=S13;
		break;
		case S13:
			m_fir16_16800010 = m_CoeffsLPAREN4RPAREN * m_ValeursLPAREN11RPAREN;
			m_temporaire0009 = m_temporaire0008 + m_fir16_16800009;
			m_state_cycle=S14;
		break;
		case S14:
			m_fir16_16800011 = m_CoeffsLPAREN3RPAREN * m_ValeursLPAREN12RPAREN;
			m_temporaire0010 = m_temporaire0009 + m_fir16_16800010;
			m_state_cycle=S15;
		break;
		case S15:
			m_fir16_16800012 = m_CoeffsLPAREN2RPAREN * m_ValeursLPAREN13RPAREN;
			m_temporaire0011 = m_temporaire0010 + m_fir16_16800011;
			m_state_cycle=S16;
		break;
		case S16:
			m_fir16_16800013 = m_CoeffsLPAREN1RPAREN * m_ValeursLPAREN14RPAREN;
			m_temporaire0012 = m_temporaire0011 + m_fir16_16800012;
			
			m_state_cycle=S17;
		break;
		case S17:
			m_temporaire0013 = m_temporaire0012 + m_fir16_16800013;			
			m_fir16_16800014 = m_CoeffsLPAREN0RPAREN * m_ValeursLPAREN15RPAREN;
			m_state_cycle=S18;
		break;
		case S18:
			m_temporaire0014 = m_temporaire0013 + m_temporaire;			
			m_state_cycle=S19;
		break;
		case S19:
			m_data_out = m_fir16_16800014 + m_temporaire0014;			
			if (p_to_ctrl.wok.read())
			{
				m_recv_buffer = m_data_out;
				r_status.output_available = true;
				m_wait_IO = false;
			}
			else m_wait_IO = true;
			if (!m_wait_IO)
			{
				m_state_cycle=S0;
				m_ValeursLPAREN15RPAREN = m_ValeursLPAREN14RPAREN; // aging
				m_ValeursLPAREN14RPAREN = m_ValeursLPAREN13RPAREN; // aging
				m_ValeursLPAREN13RPAREN = m_ValeursLPAREN12RPAREN; // aging
				m_ValeursLPAREN12RPAREN = m_ValeursLPAREN11RPAREN; // aging
				m_ValeursLPAREN11RPAREN = m_ValeursLPAREN10RPAREN; // aging
				m_ValeursLPAREN10RPAREN = m_ValeursLPAREN9RPAREN; // aging
				m_ValeursLPAREN9RPAREN = m_ValeursLPAREN8RPAREN; // aging
				m_ValeursLPAREN8RPAREN = m_ValeursLPAREN7RPAREN; // aging
				m_ValeursLPAREN7RPAREN = m_ValeursLPAREN6RPAREN; // aging
				m_ValeursLPAREN6RPAREN = m_ValeursLPAREN5RPAREN; // aging
				m_ValeursLPAREN5RPAREN = m_ValeursLPAREN4RPAREN; // aging
				m_ValeursLPAREN4RPAREN = m_ValeursLPAREN3RPAREN; // aging
				m_ValeursLPAREN3RPAREN = m_ValeursLPAREN2RPAREN; // aging
				m_ValeursLPAREN2RPAREN = m_ValeursLPAREN1RPAREN; // aging
				m_ValeursLPAREN1RPAREN = m_data_in; // aging
				r_status.done = true;
			}
		break;
	}
}
/* Moore fsm generation */
/* Evaluated on Negative Clock Edge */
tmpl(void)::genMoore()
{
	p_from_ctrl.r = (m_state_cycle == S0);
	p_to_ctrl.w = (m_state_cycle == S19);
	if(m_state_cycle == S19)
		p_to_ctrl.data = le_to_machine((uint32_t)m_recv_buffer);
}
}}
