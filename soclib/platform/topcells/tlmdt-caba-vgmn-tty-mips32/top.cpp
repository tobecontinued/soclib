/**
 ** MARKER_BEGIN
 ** Auto-generated file, dont modify directly
 ** your changes will be lost !
 **
 ** Generated by DSX on 2009-02-04 14:54:02.955548
 ** by alinev@solo
 ** MARKER_END
 **/
#include <systemc>
#include <sys/time.h>
#include <cstdlib>
#include <cstdarg>
#include <sys/timeb.h>

// 
#include "base_module.h"
#include "mapping_table.h"
#include "loader.h"
#include "iss2.h"
#include "iss2_simhelper.h"
#include "mips32.h"
#include "tty.h"
#include "vci_multi_tty.h"
#include "vci_param.h"
#include "vci_ram.h"
#include "vci_signals.h"
#include "vci_vgmn.h"
#include "vci_xcache_wrapper.h"
#include "vci_target_transactor.h"
#include "vci_initiator_transactor.h"
#include "vci_blackhole.h"
#include "segmentation.h"
// Component getIncludes
// Configurator getIncludes
// Signal getIncludes

using namespace  soclib::common;

//XCACHE_CABA 1 TTY_CABA 1 OK
//XCACHE_CABA 1 TTY_CABA 0 OK
//XCACHE_CABA 0 TTY_CABA 1 OK
//XCACHE_CABA 0 TTY_CABA 0 OK

#ifndef XCACHE_CABA
#define XCACHE_CABA 0
#endif

#ifndef RAM_CABA
#define RAM_CABA 0
#endif

#ifndef TTY_CABA
#define TTY_CABA 1
#endif

bool stop;
void run(sc_core::sc_signal<bool> &resetn, sc_core::sc_signal<bool> &clock)
{
#ifdef SYSTEMCASS
	sc_core::sc_start(0);
	resetn = false;
	sc_core::sc_start(1);
	resetn = true;
#else
	sc_core::sc_start(sc_core::sc_time(0, sc_core::SC_NS));
	resetn = false;
	sc_core::sc_start(sc_core::sc_time(1, sc_core::SC_NS));
	resetn = true;
#endif

#ifdef SOCVIEW
	debug();
#else
	const char *t = getenv("STATS_EVERY");
	if ( t ) {
		int delta = atoi(t);
		while (!stop) {
			struct timezone tz;
			struct timeval end, begin, tp;
			gettimeofday( &begin, &tz );
#ifdef SYSTEMCASS
			sc_core::sc_start(delta);
#else
			sc_core::sc_start(sc_core::sc_time(delta, sc_core::SC_NS));
#endif
			gettimeofday( &end, &tz );
			timersub( &end, &begin, &tp );
			long ms = (tp.tv_sec*1000+tp.tv_usec/1000);
			std::cout << delta << " cycles in " << ms << " ms: " << ((double)delta*1000/ms) << " c/s" << std::endl;
		}
	} else {
	  /*
	  while(1){
	    
	    sc_core::sc_start(sc_core::sc_time(1, sc_core::SC_NS));
	    clock = false;
	    sc_core::sc_start(sc_core::sc_time(1, sc_core::SC_NS));
	    clock = true;
	    
	  }
	  */
	  sc_core::sc_start();
	}
#endif
}

std::vector<std::string> stringArray(
    const char *first, ... )
{
    std::vector<std::string> ret;
	va_list arg;
	va_start(arg, first);
	const char *s = first;
	while(s) {
		ret.push_back(std::string(s));
		s = va_arg(arg, const char *);
	};
	va_end(arg);
    return ret;
}

std::vector<std::string> getTTYNames(int n)
{
    std::vector<std::string> ret;
    for(int i=0; i<n; i++){
      std::ostringstream tty_name;
      tty_name << "tty" << i;
      ret.push_back(tty_name.str());
    }
    return ret;
}

std::vector<int> intArray(
    const int length, ... )
{
	int i;
    std::vector<int> ret;
	va_list arg;
	va_start(arg, length);

	for (i=0; i<length; ++i) {
		ret.push_back(va_arg(arg, int));
	};
	va_end(arg);
    return ret;
}

int _main(int argc, char **argv)
{
  typedef soclib::caba::VciParams<4,8,32,1,1,1,8,8,8,1> vci_param_caba;
  typedef soclib::tlmdt::VciParams<uint32_t, uint32_t> vci_param_tlmdt;

  typedef Mips32ElIss iss_t;
  typedef Iss2Simhelper<iss_t> iss_simhelper_t;

  struct timeb initial, final;

  unsigned int n_initiators = 1;
  char * n_initiators_env; //env variable that says the number of initiators to be used
  n_initiators_env = getenv("N_INITS");
  if (n_initiators_env==NULL) {
    printf("WARNING : You should specify the number of initiators in variable N_INITS. For example, export N_INITS=2\n");
    printf("Using 1 initiator\n");
  }else {
    n_initiators = atoi( n_initiators_env );
    printf("Number of initiators: %d\n", n_initiators);
  }

  size_t network_latence = 10;
  char * network_latence_env; //env variable that says the global interconnect delay
  network_latence_env = getenv("NETWORK_LATENCE");
  if (network_latence_env!=NULL) {
    network_latence = atoi( network_latence_env );
  }
  
  std::cout << "SIMULATION PARAMETERS: number of initiators = " << n_initiators << " network latence = " << network_latence << std::endl << std::endl;


  /////////////////////////////////////////////////////////////////////////////
  // LOADER
  /////////////////////////////////////////////////////////////////////////////
  Loader loader("soft/bin.soft");

  /////////////////////////////////////////////////////////////////////////////
  // MAPPING TABLE
  /////////////////////////////////////////////////////////////////////////////
  MappingTable mapping_table(32, IntTab(8), IntTab(8), 0x00200000);
  mapping_table.add(Segment("boot",  RESET_BASE, RESET_SIZE, IntTab(0), 1));
  mapping_table.add(Segment("excep", EXCEP_BASE, EXCEP_SIZE, IntTab(0), 1));
  mapping_table.add(Segment("text" , TEXT_BASE , TEXT_SIZE , IntTab(0), 1));
  mapping_table.add(Segment("data" , DATA_BASE , DATA_SIZE , IntTab(1), 1));
  mapping_table.add(Segment("tty",   TTY_BASE  , TTY_SIZE  , IntTab(2), 0));

  ////////////////////////////////////////////////
  // VGMN
  ////////////////////////////////////////////////
  soclib::tlmdt::VciVgmn vgmn0("vgmn0", mapping_table, n_initiators, 3, network_latence, 8);
  std::cout << "VciVGMN TLMDT" << std::endl;
  ////////////////////////////////////////////////
  // XCACHE + MIPS
  ////////////////////////////////////////////////
#if XCACHE_CABA
  soclib::caba::VciXcacheWrapper<vci_param_caba, iss_simhelper_t>  *xcache[n_initiators];
  soclib::tlmdt::VciTargetTransactor<vci_param_caba, vci_param_tlmdt>  *xcache_vgmn_transactor[n_initiators];
  soclib::caba::VciSignals<vci_param_caba> *xcache_p_vci[n_initiators];
  sc_core::sc_signal<bool> *xcache_p_irq[n_initiators][iss_t::n_irq];

  for (unsigned int i=0 ; i < n_initiators ; i++) {
    std::ostringstream xcache_name;
    xcache_name << "xcache" << i;
    xcache[i] = new soclib::caba::VciXcacheWrapper<vci_param_caba, iss_simhelper_t>((xcache_name.str()).c_str(), i, mapping_table, soclib::common::IntTab(i), 1, 32, 8, 1, 32, 8);

    std::ostringstream xcache_transactor_name;
    xcache_transactor_name << "xcache_vgmn_transactor" << i;
#if TTY_CABA
    xcache_vgmn_transactor[i] = new soclib::tlmdt::VciTargetTransactor<vci_param_caba, vci_param_tlmdt>((xcache_transactor_name.str()).c_str());
#else
    xcache_vgmn_transactor[i] = new soclib::tlmdt::VciTargetTransactor<vci_param_caba , vci_param_tlmdt>((xcache_transactor_name.str()).c_str(), 1);
#endif

    std::ostringstream xcache_p_vci_name;
    xcache_p_vci_name << "xcache_" << i << "_p_vci";
    xcache_p_vci[i] = new soclib::caba::VciSignals<vci_param_caba>((xcache_p_vci_name.str()).c_str());

    for(unsigned int n=0; n<iss_t::n_irq; n++){
      std::ostringstream xcache_p_irq_name;
      xcache_p_irq_name << "xcache" << i << "_p_irq_" << n;
      xcache_p_irq[i][n] = new sc_core::sc_signal<bool>((xcache_p_irq_name.str()).c_str());
    }
  }

  std::cout << "VciXcacheWrapper CABA" << std::endl;
#else
  soclib::tlmdt::VciXcacheWrapper<vci_param_tlmdt, iss_simhelper_t>  *xcache[n_initiators];
  soclib::tlmdt::VciBlackhole<tlm::tlm_initiator_socket<> > *fake_initiator[n_initiators];
  
  for (unsigned int i=0 ; i < n_initiators ; i++) {
    std::ostringstream xcache_name;
    xcache_name << "xcache" << i;
    xcache[i] = new soclib::tlmdt::VciXcacheWrapper<vci_param_tlmdt, iss_simhelper_t>((xcache_name.str()).c_str(), i,  mapping_table, soclib::common::IntTab(i), 1, 32, 8, 1, 32, 8);
  
    ////////////////////////////////////////////
    // VciBlackhole Initiator
    ////////////////////////////////////////////
    std::ostringstream fake_name;
    fake_name << "fake" << "_" << i;
    fake_initiator[i] = new soclib::tlmdt::VciBlackhole<tlm::tlm_initiator_socket<> >((fake_name.str()).c_str(), iss_t::n_irq-1);
        
    for(unsigned int irq=0; irq<iss_t::n_irq-1; irq++){
      (*fake_initiator[i]->p_socket[irq])(*xcache[i]->p_irq[irq+1]);
    }
    
  }

  std::cout << "VciXcacheWrapper TLMDT" << std::endl;
#endif

  ////////////////////////////////////////////////
  // RAM0
  ////////////////////////////////////////////////
#if RAM_CABA
  soclib::caba::VciRam<vci_param_caba>  ram0("ram0", soclib::common::IntTab(0), mapping_table, loader);
  soclib::caba::VciSignals<vci_param_caba>  ram0_p_vci("ram0_p_vci");
  soclib::tlmdt::VciInitiatorTransactor<vci_param_caba, vci_param_tlmdt>  vgmn_ram_transactor("vgmn_ram_transactor");

  std::cout << "VciRam CABA" << std::endl;
#else
  soclib::tlmdt::VciRam<vci_param_tlmdt>  ram0("ram0", soclib::common::IntTab(0), mapping_table, loader);

  std::cout << "VciRam TLMDT" << std::endl;
#endif
  
  ////////////////////////////////////////////////
  // RAM1
  ////////////////////////////////////////////////
#if RAM_CABA
  soclib::caba::VciRam<vci_param_caba>  ram1("ram1", soclib::common::IntTab(1), mapping_table, loader);
  soclib::caba::VciSignals<vci_param_caba>  ram1_p_vci("ram1_p_vci");
  soclib::tlmdt::VciInitiatorTransactor<vci_param_caba, vci_param_tlmdt>  vgmn_ram1_transactor("vgmn_ram1_transactor");

  std::cout << "VciRam1 CABA" << std::endl;
#else
  soclib::tlmdt::VciRam<vci_param_tlmdt>  ram1("ram1", soclib::common::IntTab(1), mapping_table, loader);

  std::cout << "VciRam1 TLMDT" << std::endl;
#endif

  ////////////////////////////////////////////////
  // TTY
  ////////////////////////////////////////////////
#if TTY_CABA
  soclib::caba::VciMultiTty<vci_param_caba>  tty0("tty0", soclib::common::IntTab(2), mapping_table, getTTYNames(n_initiators));
  soclib::caba::VciSignals<vci_param_caba>  tty0_p_vci("tty0_p_vci");
  sc_core::sc_signal<bool> *tty_p_irq[n_initiators];
  for(unsigned int n=0; n<n_initiators; n++){
    std::ostringstream name_tty_irq;
    name_tty_irq << "tty_p_irq" << n;
    tty_p_irq[n] = new sc_core::sc_signal<bool>((name_tty_irq.str()).c_str());
  }

#if XCACHE_CABA
  soclib::tlmdt::VciInitiatorTransactor<vci_param_caba, vci_param_tlmdt>  vgmn_tty_transactor("vgmn_tty_transactor");
#else
  soclib::tlmdt::VciInitiatorTransactor<vci_param_caba, vci_param_tlmdt>  vgmn_tty_transactor("vgmn_tty_transactor", n_initiators);
#endif

  std::cout << "VciMultiTty CABA" << std::endl;
#else

  soclib::tlmdt::VciMultiTty<vci_param_tlmdt>  tty0("tty0", soclib::common::IntTab(1), mapping_table, getTTYNames(n_initiators));

  std::cout << "VciMultiTty TLMDT" << std::endl;
#endif

  ////////////////////////////////////////////////
  // SIGNALS
  ////////////////////////////////////////////////
  //sc_core::sc_clock clock("clock");
  sc_core::sc_signal<bool> clock("clock");
  sc_core::sc_signal<bool> resetn("resetn");

  ////////////////////////////////////////////////
  // CONNECTIONS
  ////////////////////////////////////////////////
#if XCACHE_CABA
  for (unsigned int i=0 ; i < n_initiators ; i++) {
    xcache[i]->p_clk(clock);
    xcache[i]->p_resetn(resetn);
    xcache[i]->p_vci(*xcache_p_vci[i]);

    xcache_vgmn_transactor[i]->p_clk(clock);
    xcache_vgmn_transactor[i]->p_resetn(resetn);
    xcache_vgmn_transactor[i]->p_vci_initiator(*vgmn0.p_to_initiator[i]);
    xcache_vgmn_transactor[i]->p_vci_target(*xcache_p_vci[i]);

#if TTY_CABA
    xcache[i]->p_irq[0](*tty_p_irq[i]);
    for(unsigned int n=1; n<iss_t::n_irq; n++)
      xcache[i]->p_irq[n](*xcache_p_irq[i][n]);
#else 
    for(unsigned int n=0; n<iss_t::n_irq; n++)
      xcache[i]->p_irq[n](*xcache_p_irq[i][n]);

    (*xcache_vgmn_transactor[i]->p_irq_target[0])(*tty0.p_irq[i]);
    xcache_vgmn_transactor[i]->p_irq_initiator[0](*xcache_p_irq[i][0]);
#endif

  }

#else
  for (unsigned int i=0 ; i < n_initiators ; i++) {
    xcache[i]->p_vci(*vgmn0.p_to_initiator[i]);

#if TTY_CABA
#else
    (*xcache[i]->p_irq[0])(*tty0.p_irq[i]);
#endif
    
  }

#endif

#if RAM_CABA
  ram0.p_clk(clock);
  ram0.p_resetn(resetn);
  ram0.p_vci(ram0_p_vci);

  vgmn_ram_transactor.p_clk(clock);
  vgmn_ram_transactor.p_resetn(resetn);
  vgmn_ram_transactor.p_vci_initiator(ram0_p_vci);
  vgmn_ram_transactor.p_vci_target(*vgmn0.p_to_target[0]);

  ram1.p_clk(clock);
  ram1.p_resetn(resetn);
  ram1.p_vci(ram1_p_vci);

  vgmn_ram1_transactor.p_clk(clock);
  vgmn_ram1_transactor.p_resetn(resetn);
  vgmn_ram1_transactor.p_vci_initiator(ram1_p_vci);
  vgmn_ram1_transactor.p_vci_target(*vgmn0.p_to_target[1]);

#else
  ram0.p_vci(*vgmn0.p_to_target[0]);
  ram1.p_vci(*vgmn0.p_to_target[1]);
#endif

#if TTY_CABA
  tty0.p_clk(clock);
  tty0.p_resetn(resetn);
  tty0.p_vci(tty0_p_vci);
  for(unsigned int n=0; n<n_initiators ; n++){
    tty0.p_irq[n](*tty_p_irq[n]);
  }

  vgmn_tty_transactor.p_clk(clock);
  vgmn_tty_transactor.p_resetn(resetn);
  vgmn_tty_transactor.p_vci_initiator(tty0_p_vci);
  vgmn_tty_transactor.p_vci_target(*vgmn0.p_to_target[2]);

#if XCACHE_CABA
#else
  for(unsigned int n=0; n<n_initiators ; n++){
    vgmn_tty_transactor.p_irq_target[n](*tty_p_irq[n]);
    (*vgmn_tty_transactor.p_irq_initiator[n])(*xcache[n]->p_irq[0]);
  }
#endif
  
#else
  tty0.p_vci(*vgmn0.p_to_target[2]);
#endif

  ////////////////////////////////////////////////
  // SIMULATION
  ////////////////////////////////////////////////
  ftime(&initial);
  run(resetn, clock);
  ftime(&final);
  
  std::cout << "Execution Time = " << (int)((1000.0 * (final.time - initial.time))+ (final.millitm - initial.millitm)) << std::endl << std::endl;
  
  return 0;
}

void quit(int)
{
	sc_core::sc_stop();
    stop = true;
}

int sc_main (int argc, char *argv[])
{
  signal(SIGINT, quit);
  atexit(sc_core::sc_stop);
  stop = false;
  
  try {
    return _main(argc, argv);
  } catch (std::exception &e) {
    std::cout << e.what() << std::endl;
  } catch (...) {
    std::cout << "Unknown exception occured" << std::endl;
    throw;
  }
  return 1;
}
