
/**
 ** MARKER_BEGIN
 ** Auto-generated file, dont modify directly
 ** your changes will be lost !
 **
 ** Generated by DSX on 2009-02-04 14:54:02.955548
 ** by alinev@solo
 ** MARKER_END
 **/
#include <systemc>
#include <sys/time.h>
#include <cstdlib>
#include <cstdarg>

// 
#include "base_module.h"
#include "loader.h"
#include "iss2_simhelper.h"
#include "mips32.h"
#include "mapping_table.h"
#include "mips32.h"
#include "tty.h"
#include "vci_multi_tty.h"
#include "vci_param.h"
#include "vci_ram.h"
#include "vci_signals.h"
#include "vci_vgmn.h"
#include "vci_xcache_wrapper.h"
#include <sys/timeb.h>
// Component getIncludes
// Configurator getIncludes
// Signal getIncludes

bool stop;
void run(sc_core::sc_signal<bool> &resetn)
{
#ifdef SYSTEMCASS
	sc_core::sc_start(0);
	resetn = false;
	sc_core::sc_start(1);
	resetn = true;
#else
	sc_core::sc_start(sc_core::sc_time(0, sc_core::SC_NS));
	resetn = false;
	sc_core::sc_start(sc_core::sc_time(1, sc_core::SC_NS));
	resetn = true;
#endif

#ifdef SOCVIEW
	debug();
#else
	const char *t = getenv("STATS_EVERY");
	if ( t ) {
		int delta = atoi(t);
		while (!stop) {
			struct timezone tz;
			struct timeval end, begin, tp;
			gettimeofday( &begin, &tz );
#ifdef SYSTEMCASS
			sc_core::sc_start(delta);
#else
			sc_core::sc_start(sc_core::sc_time(delta, sc_core::SC_NS));
#endif
			gettimeofday( &end, &tz );
			timersub( &end, &begin, &tp );
			long ms = (tp.tv_sec*1000+tp.tv_usec/1000);
			std::cout << delta << " cycles in " << ms << " ms: " << ((double)delta*1000/ms) << " c/s" << std::endl;
		}
	} else {
		sc_core::sc_start();
	}
#endif
}

std::vector<std::string> stringArray(
    const char *first, ... )
{
    std::vector<std::string> ret;
	va_list arg;
	va_start(arg, first);
	const char *s = first;
	while(s) {
		ret.push_back(std::string(s));
		s = va_arg(arg, const char *);
	};
	va_end(arg);
    return ret;
}

std::vector<int> intArray(
    const int length, ... )
{
	int i;
    std::vector<int> ret;
	va_list arg;
	va_start(arg, length);

	for (i=0; i<length; ++i) {
		ret.push_back(va_arg(arg, int));
	};
	va_end(arg);
    return ret;
}

int _main(int argc, char **argv)
{
  struct timeb initial, final;

  // Define our VCI parameters
  typedef soclib::caba::VciParams<4,8,32,1,1,1,8,1,1,1> vci_param;

  size_t dcache_size     = 32;
  size_t icache_size     = 32;
  size_t network_latence = 10;
  
  unsigned int n_initiators = 1;
  char * n_initiators_env; //env variable that says the number of initiators to be used
  n_initiators_env = getenv("N_INITS");

  if (n_initiators_env==NULL) {
    printf("WARNING : You should specify the number of initiators in variable N_INITS. For example, export N_INITS=2\n");
    printf("Using 1 initiator\n");
  }else {
    n_initiators = atoi( n_initiators_env );
  }

  uint32_t simulation_time = std::numeric_limits<uint32_t>::max();
  char * simulation_time_env; //env variable that says the simulation time
  simulation_time_env = getenv("SIMULATION_TIME");
  if (simulation_time_env==NULL) {
    printf("WARNING : You can specify the simulation time in variable SIMULATION_TIME. For example, export SIMULATION_TIME=100000\n");
  }else {
    simulation_time = atoi( simulation_time_env );
  }

  std::cout << "SIMULATION PARAMETERS: number of initiators = " << n_initiators << " simulation time = " << simulation_time << " icache size = " << icache_size << " dcache size = " << dcache_size << " network latence = " << network_latence << std::endl << std::endl;

  /////////////////////////////////////////////////////////////////////////////
  // LOADER
  /////////////////////////////////////////////////////////////////////////////
  std::ostringstream soft;
  soft << "soft/bin" << n_initiators << "proc.soft";
  soclib::common::Loader loader(soft.str());


  /////////////////////////////////////////////////////////////////////////////
  // MAPPING TABLE
  /////////////////////////////////////////////////////////////////////////////
  soclib::common::MappingTable mapping_table(32, soclib::common::IntTab(8), soclib::common::IntTab(8), 0x00200000);
  mapping_table.add(soclib::common::Segment("boot",  0xbfc00000,       2048, soclib::common::IntTab(1), 1));
  mapping_table.add(soclib::common::Segment("cram0", 0x10000000, 0x00100000, soclib::common::IntTab(0), 1));
  mapping_table.add(soclib::common::Segment("cram1", 0x20000000, 0x00100000, soclib::common::IntTab(1), 1));
  mapping_table.add(soclib::common::Segment("excep", 0x80000080,       2048, soclib::common::IntTab(1), 1));
  mapping_table.add(soclib::common::Segment("tty",   0x90200000,         32, soclib::common::IntTab(2), 0));
  mapping_table.add(soclib::common::Segment("uram0", 0x10200000, 0x00100000, soclib::common::IntTab(0), 0));
  mapping_table.add(soclib::common::Segment("uram1", 0x20200000, 0x00100000, soclib::common::IntTab(1), 0));

  ////////////////////////////////////////////////
  // VGMN
  ////////////////////////////////////////////////
  soclib::caba::VciVgmn<vci_param >  vgmn0("vgmn0", mapping_table, n_initiators, 3, network_latence, 8);
  
  ////////////////////////////////////////////////
  // XCACHE + MIPS
  ////////////////////////////////////////////////
  soclib::caba::VciXcacheWrapper<vci_param, soclib::common::Iss2Simhelper<soclib::common::Mips32ElIss> > *xcache[n_initiators];
  
  for (unsigned int i=0 ; i < n_initiators ; i++) {

    std::ostringstream xcache_name;
    xcache_name << "xcache" << i;
    xcache[i] = new soclib::caba::VciXcacheWrapper<vci_param, soclib::common::Iss2Simhelper<soclib::common::Mips32ElIss> >((xcache_name.str()).c_str(), i, mapping_table, soclib::common::IntTab(i), 1, icache_size, 8, 1, dcache_size, 8);
  }
  
  ////////////////////////////////////////////////
  // RAM
  ////////////////////////////////////////////////
  soclib::caba::VciRam<vci_param >  ram0("ram0", soclib::common::IntTab(0), mapping_table, loader);
  soclib::caba::VciRam<vci_param >  ram1("ram1", soclib::common::IntTab(1), mapping_table, loader);
  
  
  ////////////////////////////////////////////////
  // TTY
  ////////////////////////////////////////////////
  soclib::caba::VciMultiTty<vci_param >  tty0("tty0", soclib::common::IntTab(2), mapping_table, stringArray("tty0", NULL));
  
  
  ////////////////////////////////////////////////
  // SIGNALS
  ////////////////////////////////////////////////
  sc_core::sc_clock clock("clock");
  sc_core::sc_signal<bool> resetn("resetn");
  
  soclib::caba::VciSignals<vci_param> *vgmn0_p_to_initiator_to_xcache_p_vci[n_initiators];
  sc_core::sc_signal<bool> *irq[n_initiators][6];

  for (unsigned int i=0 ; i < n_initiators ; i++) {
    
    std::ostringstream vgmn;
    vgmn << "vgmn0_p_to_initiator_" << i << "_to_xcache" << i << "_p_vci";
    vgmn0_p_to_initiator_to_xcache_p_vci[i] = new soclib::caba::VciSignals<vci_param>((vgmn.str()).c_str());

    for (unsigned int j=0 ; j < 6; j++) {
      std::ostringstream name_irq;
      name_irq << "mips" << i << "_p_irq_" << j << "_";
      irq[i][j] = new sc_core::sc_signal<bool>((name_irq.str()).c_str());
    }
  }

  soclib::caba::VciSignals<vci_param>  ram0_p_vci_to_vgmn0_p_to_target_0_("ram0_p_vci_to_vgmn0_p_to_target_0_");
  soclib::caba::VciSignals<vci_param>  ram1_p_vci_to_vgmn0_p_to_target_1_("ram1_p_vci_to_vgmn0_p_to_target_1_");
  
  soclib::caba::VciSignals<vci_param>  tty0_p_vci_to_vgmn0_p_to_target_2_("tty0_p_vci_to_vgmn0_p_to_target_2_");
  
  ////////////////////////////////////////////////
  // CONNECTIONS
  ////////////////////////////////////////////////
  vgmn0.p_clk(clock);
  vgmn0.p_resetn(resetn);
  for (unsigned int i=0 ; i < n_initiators ; i++)
    vgmn0.p_to_initiator[i](*vgmn0_p_to_initiator_to_xcache_p_vci[i]);
  vgmn0.p_to_target[0](ram0_p_vci_to_vgmn0_p_to_target_0_);
  vgmn0.p_to_target[1](ram1_p_vci_to_vgmn0_p_to_target_1_);
  vgmn0.p_to_target[2](tty0_p_vci_to_vgmn0_p_to_target_2_);
  
  for (unsigned int i=0 ; i < n_initiators ; i++) {
    xcache[i]->p_clk(clock);
    xcache[i]->p_resetn(resetn);
    xcache[i]->p_vci(*vgmn0_p_to_initiator_to_xcache_p_vci[i]);
    for (unsigned int j=0 ; j < 6; j++) {
      xcache[i]->p_irq[j](*irq[i][j]);
    }
  }

  ram0.p_clk(clock);
  ram0.p_resetn(resetn);
  ram0.p_vci(ram0_p_vci_to_vgmn0_p_to_target_0_);
  ram1.p_clk(clock);
  ram1.p_resetn(resetn);
  ram1.p_vci(ram1_p_vci_to_vgmn0_p_to_target_1_);
  tty0.p_clk(clock);
  tty0.p_irq[0](*new sc_core::sc_signal<bool>("tty0_p_irq_0_"));
  tty0.p_resetn(resetn);
  tty0.p_vci(tty0_p_vci_to_vgmn0_p_to_target_2_);
  
  
  ////////////////////////////////////////////////
  // SIMULATION
  ////////////////////////////////////////////////
  ftime(&initial);
  run(resetn);
  ftime(&final);
  
  std::cout << "Execution Time = " << (int)((1000.0 * (final.time - initial.time))+ (final.millitm - initial.millitm)) << std::endl << std::endl;

  ram0.print_stats();
  ram1.print_stats();
  tty0.print_stats();

  return 0;
}

void quit(int)
{
	sc_core::sc_stop();
    stop = true;
}

int sc_main (int argc, char *argv[])
{
	signal(SIGINT, quit);
	atexit(sc_core::sc_stop);
    stop = false;

	try {
		return _main(argc, argv);
	} catch (std::exception &e) {
		std::cout << e.what() << std::endl;
	} catch (...) {
		std::cout << "Unknown exception occured" << std::endl;
		throw;
	}
	return 1;
}
