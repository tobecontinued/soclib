
/**
 ** MARKER_BEGIN
 ** Auto-generated file, dont modify directly
 ** your changes will be lost !
 **
 ** Generated by DSX on 2008-09-09 12:22:30.397280
 ** by alinev@rock
 ** MARKER_END
 **/
#include <systemc>
#include <sys/time.h>
#include <cstdlib>
#include <cstdarg>

// 
#include "base_module.h"
#include "elf_loader.h"
#include "exception.h"
#include "fifo_reader.h"
#include "fifo_signals.h"
#include "fifo_writer.h"
#include "iss.h"
#include "iss_wrapper.h"
#include "mapping_table.h"
#include "mips.h"
#include "mwmr_controller.h"
#include "tty.h"
#include "vci_multi_tty.h"
#include "vci_mwmr_controller.h"
#include "vci_param.h"
#include "vci_ram.h"
#include "vci_signals.h"
#include "vci_vgmn.h"
#include "vci_xcache.h"
#include "xcache_signals.h"
#include <sys/timeb.h>
// Component getIncludes
// Configurator getIncludes
// Signal getIncludes

void run(sc_core::sc_signal<bool> &resetn)
{
#ifdef SYSTEMCASS
	sc_core::sc_start(0);
	resetn = false;
	sc_core::sc_start(1);
	resetn = true;
#else
	sc_core::sc_start(sc_core::sc_time(0, sc_core::SC_NS));
	resetn = false;
	sc_core::sc_start(sc_core::sc_time(1, sc_core::SC_NS));
	resetn = true;
#endif

#ifdef SOCVIEW
	debug();
#else
	const char *t = getenv("STATS_EVERY");
	if ( t ) {
		int delta = atoi(t);
		for (;;) {
			struct timezone tz;
			struct timeval end, begin, tp;
			gettimeofday( &begin, &tz );
#ifdef SYSTEMCASS
			sc_core::sc_start(delta);
#else
			sc_core::sc_start(sc_core::sc_time(delta, sc_core::SC_NS));
#endif
			gettimeofday( &end, &tz );
			timersub( &end, &begin, &tp );
			long ms = (tp.tv_sec*1000+tp.tv_usec/1000);
			std::cout << delta << " cycles in " << ms << " ms: " << ((double)delta*1000/ms) << " c/s" << std::endl;
		}
	} else {
		sc_core::sc_start();
	}
#endif
}

std::vector<std::string> stringArray(
    const char *first, ... )
{
    std::vector<std::string> ret;
	va_list arg;
	va_start(arg, first);
	const char *s = first;
	while(s) {
		ret.push_back(std::string(s));
		s = va_arg(arg, const char *);
	};
	va_end(arg);
    return ret;
}

std::vector<int> intArray(
    const int length, ... )
{
	int i;
    std::vector<int> ret;
	va_list arg;
	va_start(arg, length);

	for (i=0; i<length; ++i) {
		ret.push_back(va_arg(arg, int));
	};
	va_end(arg);
    return ret;
}

int _main(int argc, char **argv)
{
  struct timeb initial, final;

  size_t simulation_time = std::numeric_limits<uint32_t>::max();
  size_t dcache_size     = 1024;
  size_t icache_size     = 1024;
  size_t network_latence = 2;

  if(argc > 1)
    simulation_time = atoi(argv[1]);
  if(argc > 2)
    icache_size = atoi(argv[2]);
  if(argc > 3)
    dcache_size = atoi(argv[3]);
  if(argc > 4)
    network_latence = atoi(argv[4]);

  std::cout << "SIMULATION PARAMETERS: simulation time = " << simulation_time << " icache size = " << icache_size << " dcache size = " << dcache_size << " network latence = " << network_latence << std::endl << std::endl;

  ftime(&initial);

	// Configurator instanciateOnStack
	soclib::common::ElfLoader loader("soft/bin2proc.soft");
	soclib::common::MappingTable mapping_table(32, soclib::common::IntTab(8), soclib::common::IntTab(8), 0x00200000);

	// Configurator configure
	mapping_table.add(soclib::common::Segment("boot", 0xbfc00000, 2048, soclib::common::IntTab(1), 1));
	mapping_table.add(soclib::common::Segment("cram0", 0x10000000, 0x00100000, soclib::common::IntTab(0), 1));
	mapping_table.add(soclib::common::Segment("cram1", 0x20000000, 0x00100000, soclib::common::IntTab(1), 1));
	mapping_table.add(soclib::common::Segment("excep", 0x80000080, 2048, soclib::common::IntTab(1), 1));
	mapping_table.add(soclib::common::Segment("ramdac_ctrl", 0x71200000, 256, soclib::common::IntTab(4), 0));
	mapping_table.add(soclib::common::Segment("tg_ctrl", 0x70200000, 256, soclib::common::IntTab(3), 0));
	mapping_table.add(soclib::common::Segment("tty0", 0x90200000, 32, soclib::common::IntTab(2), 0));
	mapping_table.add(soclib::common::Segment("uram0", 0x10200000, 0x00100000, soclib::common::IntTab(0), 0));
	mapping_table.add(soclib::common::Segment("uram1", 0x20200000, 0x00100000, soclib::common::IntTab(1), 0));

	// Component instanciateOnStack
	soclib::caba::FifoReader<uint32_t>  tg("tg", "bash", stringArray("bash", "-c", "while cat \"plan.jpg\" ; do true ; done", NULL));
	soclib::caba::FifoWriter<uint32_t>  ramdac("ramdac", "soclib-pipe2fb", stringArray("soclib-pipe2fb", "48", "48", NULL));
	soclib::caba::IssWrapper<soclib::common::MipsElIss>  mips0("mips0", 0);
	soclib::caba::IssWrapper<soclib::common::MipsElIss>  mips1("mips1", 1);
	soclib::caba::VciMultiTty<soclib::caba::VciParams<4,8,32,1,1,1,8,1,1,1> >  tty0("tty0", soclib::common::IntTab(2), mapping_table, stringArray("tty0", NULL));
	soclib::caba::VciMwmrController<soclib::caba::VciParams<4,8,32,1,1,1,8,1,1,1> >  ramdac_ctrl("ramdac_ctrl", mapping_table, soclib::common::IntTab(3), soclib::common::IntTab(4), 64, 96, 0, 1, 0, 0, 0, true);
	soclib::caba::VciMwmrController<soclib::caba::VciParams<4,8,32,1,1,1,8,1,1,1> >  tg_ctrl("tg_ctrl", mapping_table, soclib::common::IntTab(2), soclib::common::IntTab(3), 64, 0, 8, 0, 1, 0, 0, true);
	soclib::caba::VciRam<soclib::caba::VciParams<4,8,32,1,1,1,8,1,1,1> >  ram0("ram0", soclib::common::IntTab(0), mapping_table, loader);
	soclib::caba::VciRam<soclib::caba::VciParams<4,8,32,1,1,1,8,1,1,1> >  ram1("ram1", soclib::common::IntTab(1), mapping_table, loader);
	soclib::caba::VciVgmn<soclib::caba::VciParams<4,8,32,1,1,1,8,1,1,1> >  vgmn0("vgmn0", mapping_table, 4, 5, network_latence, 8);
	soclib::caba::VciXCache<soclib::caba::VciParams<4,8,32,1,1,1,8,1,1,1> >  xcache0("xcache0", mapping_table, soclib::common::IntTab(0), icache_size, 8, dcache_size, 8);
	soclib::caba::VciXCache<soclib::caba::VciParams<4,8,32,1,1,1,8,1,1,1> >  xcache1("xcache1", mapping_table, soclib::common::IntTab(1), icache_size, 8, dcache_size, 8);

	// Signal instanciateOnStack
	// not mips0_p_irq_0_;
	// not mips0_p_irq_1_;
	// not mips0_p_irq_2_;
	// not mips0_p_irq_3_;
	// not mips0_p_irq_4_;
	// not mips0_p_irq_5_;
	// not mips1_p_irq_0_;
	// not mips1_p_irq_1_;
	// not mips1_p_irq_2_;
	// not mips1_p_irq_3_;
	// not mips1_p_irq_4_;
	// not mips1_p_irq_5_;
	// not tty0_p_irq_0_;
	sc_core::sc_clock clock("clock");
	sc_core::sc_signal<bool> resetn("resetn");
	soclib::caba::DCacheSignals mips0_p_dcache_to_xcache0_p_dcache("mips0_p_dcache_to_xcache0_p_dcache");
	soclib::caba::DCacheSignals mips1_p_dcache_to_xcache1_p_dcache("mips1_p_dcache_to_xcache1_p_dcache");
	soclib::caba::FifoSignals<uint32_t>  ramdac_ctrl_p_to_coproc_0__to_ramdac_p_fifo("ramdac_ctrl_p_to_coproc_0__to_ramdac_p_fifo");
	soclib::caba::FifoSignals<uint32_t>  tg_ctrl_p_from_coproc_0__to_tg_p_fifo("tg_ctrl_p_from_coproc_0__to_tg_p_fifo");
	soclib::caba::ICacheSignals mips0_p_icache_to_xcache0_p_icache("mips0_p_icache_to_xcache0_p_icache");
	soclib::caba::ICacheSignals mips1_p_icache_to_xcache1_p_icache("mips1_p_icache_to_xcache1_p_icache");
	soclib::caba::VciSignals<soclib::caba::VciParams<4,8,32,1,1,1,8,1,1,1> >  ram0_p_vci_to_vgmn0_p_to_target_0_("ram0_p_vci_to_vgmn0_p_to_target_0_");
	soclib::caba::VciSignals<soclib::caba::VciParams<4,8,32,1,1,1,8,1,1,1> >  ram1_p_vci_to_vgmn0_p_to_target_1_("ram1_p_vci_to_vgmn0_p_to_target_1_");
	soclib::caba::VciSignals<soclib::caba::VciParams<4,8,32,1,1,1,8,1,1,1> >  ramdac_ctrl_p_vci_initiator_to_vgmn0_p_to_initiator_3_("ramdac_ctrl_p_vci_initiator_to_vgmn0_p_to_initiator_3_");
	soclib::caba::VciSignals<soclib::caba::VciParams<4,8,32,1,1,1,8,1,1,1> >  ramdac_ctrl_p_vci_target_to_vgmn0_p_to_target_4_("ramdac_ctrl_p_vci_target_to_vgmn0_p_to_target_4_");
	soclib::caba::VciSignals<soclib::caba::VciParams<4,8,32,1,1,1,8,1,1,1> >  tg_ctrl_p_vci_initiator_to_vgmn0_p_to_initiator_2_("tg_ctrl_p_vci_initiator_to_vgmn0_p_to_initiator_2_");
	soclib::caba::VciSignals<soclib::caba::VciParams<4,8,32,1,1,1,8,1,1,1> >  tg_ctrl_p_vci_target_to_vgmn0_p_to_target_3_("tg_ctrl_p_vci_target_to_vgmn0_p_to_target_3_");
	soclib::caba::VciSignals<soclib::caba::VciParams<4,8,32,1,1,1,8,1,1,1> >  tty0_p_vci_to_vgmn0_p_to_target_2_("tty0_p_vci_to_vgmn0_p_to_target_2_");
	soclib::caba::VciSignals<soclib::caba::VciParams<4,8,32,1,1,1,8,1,1,1> >  vgmn0_p_to_initiator_0__to_xcache0_p_vci("vgmn0_p_to_initiator_0__to_xcache0_p_vci");
	soclib::caba::VciSignals<soclib::caba::VciParams<4,8,32,1,1,1,8,1,1,1> >  vgmn0_p_to_initiator_1__to_xcache1_p_vci("vgmn0_p_to_initiator_1__to_xcache1_p_vci");

	// Component configure
	mips0.setCacheInfo(xcache0.getCacheInfo());
	mips1.setCacheInfo(xcache1.getCacheInfo());

	// Signal configure

	// Component connect
	mips0.p_clk(clock);
	mips0.p_dcache(mips0_p_dcache_to_xcache0_p_dcache);
	mips0.p_icache(mips0_p_icache_to_xcache0_p_icache);
	mips0.p_irq[0](*new sc_core::sc_signal<bool>("mips0_p_irq_0_"));
	mips0.p_irq[1](*new sc_core::sc_signal<bool>("mips0_p_irq_1_"));
	mips0.p_irq[2](*new sc_core::sc_signal<bool>("mips0_p_irq_2_"));
	mips0.p_irq[3](*new sc_core::sc_signal<bool>("mips0_p_irq_3_"));
	mips0.p_irq[4](*new sc_core::sc_signal<bool>("mips0_p_irq_4_"));
	mips0.p_irq[5](*new sc_core::sc_signal<bool>("mips0_p_irq_5_"));
	mips0.p_resetn(resetn);
	mips1.p_clk(clock);
	mips1.p_dcache(mips1_p_dcache_to_xcache1_p_dcache);
	mips1.p_icache(mips1_p_icache_to_xcache1_p_icache);
	mips1.p_irq[0](*new sc_core::sc_signal<bool>("mips1_p_irq_0_"));
	mips1.p_irq[1](*new sc_core::sc_signal<bool>("mips1_p_irq_1_"));
	mips1.p_irq[2](*new sc_core::sc_signal<bool>("mips1_p_irq_2_"));
	mips1.p_irq[3](*new sc_core::sc_signal<bool>("mips1_p_irq_3_"));
	mips1.p_irq[4](*new sc_core::sc_signal<bool>("mips1_p_irq_4_"));
	mips1.p_irq[5](*new sc_core::sc_signal<bool>("mips1_p_irq_5_"));
	mips1.p_resetn(resetn);
	ram0.p_clk(clock);
	ram0.p_resetn(resetn);
	ram0.p_vci(ram0_p_vci_to_vgmn0_p_to_target_0_);
	ram1.p_clk(clock);
	ram1.p_resetn(resetn);
	ram1.p_vci(ram1_p_vci_to_vgmn0_p_to_target_1_);
	ramdac.p_clk(clock);
	ramdac.p_fifo(ramdac_ctrl_p_to_coproc_0__to_ramdac_p_fifo);
	ramdac.p_resetn(resetn);
	ramdac_ctrl.p_clk(clock);
	ramdac_ctrl.p_resetn(resetn);
	ramdac_ctrl.p_to_coproc[0](ramdac_ctrl_p_to_coproc_0__to_ramdac_p_fifo);
	ramdac_ctrl.p_vci_initiator(ramdac_ctrl_p_vci_initiator_to_vgmn0_p_to_initiator_3_);
	ramdac_ctrl.p_vci_target(ramdac_ctrl_p_vci_target_to_vgmn0_p_to_target_4_);
	tg.p_clk(clock);
	tg.p_fifo(tg_ctrl_p_from_coproc_0__to_tg_p_fifo);
	tg.p_resetn(resetn);
	tg_ctrl.p_clk(clock);
	tg_ctrl.p_from_coproc[0](tg_ctrl_p_from_coproc_0__to_tg_p_fifo);
	tg_ctrl.p_resetn(resetn);
	tg_ctrl.p_vci_initiator(tg_ctrl_p_vci_initiator_to_vgmn0_p_to_initiator_2_);
	tg_ctrl.p_vci_target(tg_ctrl_p_vci_target_to_vgmn0_p_to_target_3_);
	tty0.p_clk(clock);
	tty0.p_irq[0](*new sc_core::sc_signal<bool>("tty0_p_irq_0_"));
	tty0.p_resetn(resetn);
	tty0.p_vci(tty0_p_vci_to_vgmn0_p_to_target_2_);
	vgmn0.p_clk(clock);
	vgmn0.p_resetn(resetn);
	vgmn0.p_to_initiator[0](vgmn0_p_to_initiator_0__to_xcache0_p_vci);
	vgmn0.p_to_initiator[1](vgmn0_p_to_initiator_1__to_xcache1_p_vci);
	vgmn0.p_to_initiator[2](tg_ctrl_p_vci_initiator_to_vgmn0_p_to_initiator_2_);
	vgmn0.p_to_initiator[3](ramdac_ctrl_p_vci_initiator_to_vgmn0_p_to_initiator_3_);
	vgmn0.p_to_target[0](ram0_p_vci_to_vgmn0_p_to_target_0_);
	vgmn0.p_to_target[1](ram1_p_vci_to_vgmn0_p_to_target_1_);
	vgmn0.p_to_target[2](tty0_p_vci_to_vgmn0_p_to_target_2_);
	vgmn0.p_to_target[3](tg_ctrl_p_vci_target_to_vgmn0_p_to_target_3_);
	vgmn0.p_to_target[4](ramdac_ctrl_p_vci_target_to_vgmn0_p_to_target_4_);
	xcache0.p_clk(clock);
	xcache0.p_dcache(mips0_p_dcache_to_xcache0_p_dcache);
	xcache0.p_icache(mips0_p_icache_to_xcache0_p_icache);
	xcache0.p_resetn(resetn);
	xcache0.p_vci(vgmn0_p_to_initiator_0__to_xcache0_p_vci);
	xcache1.p_clk(clock);
	xcache1.p_dcache(mips1_p_dcache_to_xcache1_p_dcache);
	xcache1.p_icache(mips1_p_icache_to_xcache1_p_icache);
	xcache1.p_resetn(resetn);
	xcache1.p_vci(vgmn0_p_to_initiator_1__to_xcache1_p_vci);

run(resetn);

  ftime(&final);

  std::cout << "Execution Time = " << (int)((1000.0 * (final.time - initial.time))+ (final.millitm - initial.millitm)) << std::endl << std::endl;

  return 0;
}

void quit(int)
{
	sc_core::sc_stop();
}

int sc_main (int argc, char *argv[])
{
	signal(SIGINT, quit);
	atexit(sc_core::sc_stop);

	try {
		return _main(argc, argv);
	} catch (std::exception &e) {
		std::cout << e.what() << std::endl;
	} catch (...) {
		std::cout << "Unknown exception occured" << std::endl;
		throw;
	}
	return 1;
}
