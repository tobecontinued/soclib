######################################################################################
#	File : isr.s
#	Authors : Alain Greiner & Franck Wajsburt
#	Date : 15/10/2009
######################################################################################
#	These routines must be "intalled" by the boot code in the
#	interrupt vector, depending on the system architecture.
#	The processor index must be in the range [0...7].
######################################################################################

	.section .isr,"ax",@progbits

######################################################################################
#		_isr_dma
#	This ISR acknowledges the interrupt from the dma controler,
#	reset the global variable _dma_busy for software signaling,
#       after copying the DMA status in _dma_status.
#	Registers $4, $5, $6 are modified.
######################################################################################
	.extern		_dma_busy
	.extern		_dma_status
	.extern		seg_dma_base
	.global		_isr_dma		# makes isr_dma an external symbol
	.align		2
_isr_dma:
	la	$4,	seg_dma_base		# $4 <= dma base address
        lw	$5,	8($4)			# $5 <= dma status
        la	$6,	_dma_status		# $6 <= _dma_status address
	sw	$5,	0($6)			# set _dma_status	
	la	$6,	_dma_busy		# $6 <= _dma_busy address
	sw	$0,	0($6)			# reset _dma_busy
	sw	$0,	12($4)			# reset IRQ 
	jr	$31				# returns to interrupt handler

######################################################################################
#		_isr_ioc
#	This ISR acknowledges the interrupt from the block device,
#	reset the global variable _ioc_busy for software signaling,
#       after copying the IOC status in _ioc_status.
#	Registers $4, $5, $6 are modified.
######################################################################################
	.extern		_ioc_busy
	.extern		_ioc_status
	.extern		seg_ioc_base
	.global		_isr_ioc		# makes isr_ioc an external symbol
	.align		2
_isr_ioc:
	la	$4,	seg_ioc_base		# $4 <= ioc base address
	lw	$5,	16($4)			# reset IRQ and load status in $5
        la	$6,	_ioc_status		# $6 <= _ioc_status address
	sw	$5,	0($6)			# set _ioc_status	
	la	$6,	_ioc_busy		# $6 <= _ioc_busy address
	sw	$0,	0($6)			# reset _ioc_busy
	jr	$31				# returns to interrupt handler

######################################################################################
#		_isr_timer
#	This ISR handles up to 8 IRQs generated by 8 independant timers,
#	and connected to 8 different processors.
#	The behaviour depends on the processor id:
#	It acknowledges the IRQ on TIMER[id] and displays a message on TTY[id] 
#	Registers $4, $5, $6 are mofified.
######################################################################################
	.extern		_tty_write
	.extern		_itoa_dec
	.extern		seg_timer_base
	.global		_isr_timer		# makes _isr_timer an external symbol
	.align		2
_isr_timer:
	addiu	$29,	$29,	-4		# save return address in stack
	sw	$31,	0($29)

	mfc0	$4,	$15,	1		
	andi	$4,	$4,	0x7		# $4 <= proc_id
	sll	$5,	$4,	4		# $5 <= proc_id * 16
	la	$6,	seg_timer_base		# load timer base address
	add	$6,	$6,	$5		# $6 <= timer[i] base address
	sw	$0,	12($6)			# reset IRQ
	la	$5,	message_timer_begin	# $5 <= buffer address
	li	$6,	40			# $6 <= length
	jal	_tty_write			# print message

	mfc0	$4,	$9			# $4 <= cycle number
	la	$5,	isr_timer_buffer	# $5 <= buffer address
	jal	_itoa_dec			# fill buffer 

	mfc0	$4,	$15,	1
	andi	$4,	$4,	0x7		# $4 <= tty_index
	la	$5,	isr_timer_buffer   	# $5 <= buffer address
	li	$6,	10			# $6 <= length
	jal	_tty_write			# print cycle number

	mfc0	$4,	$15,	1
	andi	$4,	$4,	0x7		# $4 <= proc_id
	la	$5,	message_timer_end  	# $5 <= buffer address
	li	$6,	2			# $6 <= length
	jal	_tty_write			# print message

	lw	$31,	0($29)			# restore return address from stack
	addiu	$29,	$29,	4
	jr	$31				# returns to interrupt handler

message_timer_begin:
	.ascii "\n!!! interrupt timer received at cycle: "
message_timer_end:
	.ascii "\n\n"
isr_timer_buffer:
	.ascii "0000000000"
	.align		2

######################################################################################
#		_isr_tty_get & _isr_tty_get_task* (* = 0,1,2,3)
#	These five ISRs handle up to 16 IRQs generated by 16 different TTY terminals.
#	For _isr_tty_get, the tty index is directly the proc_id.
#	For _isr_tty_get_task*, the tty index is computed as proc_id*4 + task_id.
#	There is one communication buffer _tty_get_buf[tty_id] per terminal.
#       protected by a status variable _tty_get_full[tty_id].
#       Both variables are defined in the syscalls.c file.
#	The producer is the TTY executing the ISR code, and the consumer 
#	is the OS executing the _tty_read function.
#	The set/reset _tty_get_full[id] synchronisation variable is set 
#	by the producer, and reset by the consumer.
#	The new character is lost if the TTY_BUF_GET buffer is full when the ISR
#       is executed: The IRQ is acknowledged, but nothing  is written in the buffer. 
#	Registers $4, $5, $6, $7 are modified.
######################################################################################
	.extern		_tty_get_buf
	.extern		_tty_get_full
	.extern		seg_tty_base
	.global		_isr_tty_get 		# makes it an external symbol
	.global		_isr_tty_get_task0 	# makes it an external symbol
	.global		_isr_tty_get_task1 	# makes it an external symbol
	.global		_isr_tty_get_task2 	# makes it an external symbol
	.global		_isr_tty_get_task3 	# makes it an external symbol
_isr_tty_get:
	mfc0	$4,	$15,	1
	andi	$4,	$4,	0x7		# $4 <= tty_id = proc_id
	j	tty_get_start
_isr_tty_get_task0:
	mfc0	$4,	$15,	1
	andi	$4,	$4,	0x7		# $4 <= proc_id
	sll	$4,	$4,	2		# $4 <= 4*proc_id
	addiu	$4,	$4,	0		# $4 <= 4*proc_id + 0
	j	tty_get_start
_isr_tty_get_task1:
	mfc0	$4,	$15,	1
	andi	$4,	$4,	0x7		# $4 <= proc_id
	sll	$4,	$4,	2		# $4 <= 4*proc_id
	addiu	$4,	$4,	1		# $4 <= 4*proc_id + 1
	j	tty_get_start
_isr_tty_get_task2:
	mfc0	$4,	$15,	1
	andi	$4,	$4,	0x7		# $4 <= proc_id
	sll	$4,	$4,	2		# $4 <= 4*proc_id
	addiu	$4,	$4,	2		# $4 <= 4*proc_id + 2
	j	tty_get_start
_isr_tty_get_task3:
	mfc0	$4,	$15,	1
	andi	$4,	$4,	0x7		# $4 <= proc_id
	sll	$4,	$4,	2		# $4 <= 4*proc_id
	addiu	$4,	$4,	3		# $4 <= 4*proc_id + 3
tty_get_start:
	la	$6,	seg_tty_base	
	sll	$5,	$4,	4		# $5 <= 16*(tty_id)
	addu	$6,	$6,	$5		# $6 <= seg_tty_base + 16*tty_id
	lb	$7,	8($6)			# $26 <= character & reset IRQ
        la	$6,	_tty_get_full		# $6 <= &_tty_get_full[0]
	sll	$5,	$4,	2		# $5 <= 4*(proc_id + 4*task_id)
	addu	$6,	$6,	$5		# $6 <= &_tty_get_full[proc_id + 4*task_id]
        lw	$5,	0($6)			# $5 <= buffer status
	bne	$5,	$0,	tty_get_exit	# test if buffer full 
	li	$5,	1			# $5 <= 1
        sw	$5,	0($6)			# update buffer status
	la	$6,	_tty_get_buf 		# $6 <= &_tty_get_buf[0]
	addu	$6,	$6,	$4		# $6 <= &_tty_get_buf[id]
	sb	$7,	0($6)			# writes character in _tty_get_buf[]
tty_get_exit:
	jr	$31				# returns to interrupt handler

######################################################################################
#               _isr_switch
#       This ISR is in charge of context switch.
#	It handles up to 4 different IRQs, corresponding to 4 different processors.
#       The behaviour depends on the processor_id :
#       It acknowledges the IRQ on TIMER[id] and calls the _ctx_switch function.
#       Registers $4, $5, $6 are modified.
######################################################################################
        .extern         seg_timer_base
        .extern         _ctx_switch
        .global         _isr_switch             # makes _isr_switch an external symbol
        .align          2
_isr_switch:
        addiu   $29,    $29,    -4              # save return address in stack
        sw      $31,    0($29)
        mfc0    $4,     $15,    1               # access processor index
        andi    $4,     $4,     0x3             # $4 <= processor index
        sll     $5,     $4,     4               # $5 <= processor index * 16
        la      $6,     seg_timer_base          # load timer base address
        add     $6,     $6,     $5              # $6 <= timer[i] base address
        sw      $0,     12($6)                  # reset IRQ

        jal     _ctx_switch                     # call _ctx_switch

        lw      $31,    0($29)                  # restore return address from stack
        addiu   $29,    $29,    4
        jr      $31                             # returns to interrupt handler

######################################################################################
