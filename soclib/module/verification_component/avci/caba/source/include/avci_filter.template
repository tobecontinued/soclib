/* -*- c++ -*-
 *
 * SOCLIB_LGPL_HEADER_BEGIN
 * 
 * This file is part of SoCLib, GNU LGPLv2.1.
 * 
 * SoCLib is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation; version 2.1 of the License.
 * 
 * SoCLib is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with SoCLib; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * SOCLIB_LGPL_HEADER_END
 *
 * Copyright (c) CEA
 *
 * Authors: Franck Vedrine <franck.vedrine@cea.fr>, 2008
 */

#ifndef SOCLIB_CABA_PVDC_ADVANCED_FILTERTEMPLATE
#define SOCLIB_CABA_PVDC_ADVANCED_FILTERTEMPLATE

#include "caba/verification/avci_filter.h"

namespace soclib { namespace caba {

template <typename vci_param>
void
AdvancedVciFilter<vci_param>::testHandshake() { // see p 41, 42, verified on the waveforms
   switch (sRequestState) {
      case SIdle:
         if (in.cmdval) {
            acquireRequestCell();
            if (out.cmdack)
               sRequestState = SSync;
            else
               sRequestState = SValid;
         }
         else if (out.cmdack)
            sRequestState = SDefault_Ack;
         break;
      case SValid:
         assume(in.cmdval);
         assume((in.address == addressPrevious) && (in.be == bePrevious)
            && (in.cfixed == cfixedPrevious) && (in.clen == clenPrevious)
            && (in.cmd == cmdPrevious) && (in.contig == contigPrevious)
            && (in.wdata == wdataPrevious) && (in.eop == eopPrevious)
            && (in.cons == consPrevious) && (in.plen == plenPrevious)
            && (in.wrap == wrapPrevious));
         if (out.cmdack)
            sRequestState = SSync;
         break;
      case SDefault_Ack:
         assume(out.cmdack);
         if (in.cmdval) {
            acquireRequestCell();
            sRequestState = SSync;
         };
         break;
      case SSync:
         if (!in.cmdval) {
            if (!out.cmdack)
               sRequestState = SIdle;
            else
               sRequestState = SDefault_Ack;
         }
         else {
            acquireRequestCell();
            if (!out.cmdack)
               sRequestState = SValid;
         };
         break;
   };
 
   switch (sResponseState) {
      case SIdle:
         if (out.rspval) {
            acquireResponseCell();
            if (in.rspack)
               sResponseState = SSync;
            else
               sResponseState = SValid;
         }
         else if (in.rspack)
            sResponseState = SDefault_Ack;
         break;
      case SValid:
         assume(out.rspval);
         assume((out.rdata == rdataPrevious) && (out.reop == reopPrevious)
            && (out.rerror == rerrorPrevious));
         if (in.rspack)
            sResponseState = SSync;
         break;
      case SDefault_Ack:
         assume(in.rspack);
         if (out.rspval) {
            acquireResponseCell();
            sResponseState = SSync;
         };
         break;
      case SSync:
         if (!out.rspval) {
            if (!in.rspack)
               sResponseState = SIdle;
            else
               sResponseState = SDefault_Ack;
         }
         else {
            acquireResponseCell();
            if (!in.rspack)
               sResponseState = SValid;
         };
         break;
   };
}

template <typename vci_param>
void
AdvancedVciFilter<vci_param>::LockedAddress::add(typename vci_param::srcid_t srcid,
      typename vci_param::addr_t aAddress) {
  AddressInterval aiInterval(srcid, aAddress);
   typename std::set<AddressInterval>::iterator iter = saiAddresses.find(aiInterval);
   if (iter == saiAddresses.end())
      saiAddresses.insert(iter, aiInterval);
   else {
      AddressInterval& aiCurrent = const_cast<AddressInterval&>(*iter);
      aiCurrent.merge(aiInterval);
      ++iter;
      if (iter != saiAddresses.end() && (aiCurrent == *iter))
         saiAddresses.erase(iter);
      iter = saiAddresses.find(aiInterval);
      if (&*iter == &aiCurrent) {
         if (iter != saiAddresses.begin()) {
            --iter;
            if (aiCurrent == *iter)
               saiAddresses.erase(iter);
         };
      }
      else {
         if (aiCurrent == *iter)
            saiAddresses.erase(iter);
      };   
   };
}

template <typename vci_param>
void
AdvancedVciFilter<vci_param>::LockedAddress::add(typename vci_param::srcid_t srcid,
      typename vci_param::addr_t aAddress, int plen) {
   AddressInterval aiInterval(srcid, aAddress, plen);
   typename std::set<AddressInterval>::iterator iter = saiAddresses.find(aiInterval);
   if (iter == saiAddresses.end())
      saiAddresses.insert(iter, aiInterval);
   else {
      AddressInterval& aiCurrent = const_cast<AddressInterval&>(*iter);
      aiCurrent.merge(aiInterval);
      ++iter;
      if (iter != saiAddresses.end() && (aiCurrent == *iter))
         saiAddresses.erase(iter);
      iter = saiAddresses.find(aiInterval);
      if (&*iter == &aiCurrent) {
         if (iter != saiAddresses.begin()) {
            --iter;
            if (aiCurrent == *iter)
               saiAddresses.erase(iter);
         };
      }
      else {
         if (aiCurrent == *iter)
            saiAddresses.erase(iter);
      };   
   };
}

template <typename vci_param>
void
AdvancedVciFilter<vci_param>::LockedAddress::remove(AdvancedVciFilter& filter,
      typename vci_param::srcid_t srcid, typename vci_param::addr_t aAddress) {
   AddressInterval aiInterval(srcid, aAddress);
   typename std::set<AddressInterval>::iterator iter = saiAddresses.find(aiInterval);
   if (iter != saiAddresses.end()) {
      AddressInterval* paiOther = NULL;
      bool fExtern = false;
      bool fDelete = const_cast<AddressInterval&>(*iter).remove(filter, aiInterval, paiOther, fExtern);
      if (fDelete)
         saiAddresses.erase(iter);
      else if (paiOther) {
         saiAddresses.insert(iter, *paiOther);
         delete paiOther;
      };
   };
}

template <typename vci_param>
void
AdvancedVciFilter<vci_param>::LockedAddress::remove(AdvancedVciFilter& filter,
      typename vci_param::srcid_t srcid, typename vci_param::addr_t aAddress, int plen) {
   AddressInterval aiInterval(srcid, aAddress, plen);
   typename std::set<AddressInterval>::iterator iter = saiAddresses.find(aiInterval);
   if (iter != saiAddresses.end()) {
      AddressInterval* paiOther = NULL;
      bool fExtern = false;
      bool fDelete = const_cast<AddressInterval&>(*iter).remove(filter, aiInterval, paiOther, fExtern);
      if (fDelete)
         saiAddresses.erase(iter);
      else if (paiOther) {
         saiAddresses.insert(iter, *paiOther);
         delete paiOther;
      };
   };
}

template <typename vci_param>
void
AdvancedVciFilter<vci_param>::acquireRequestCell() {
   if (uRequestCells == 0) {
      if (packetClen > 0) {
         ++packetClen;
         assume(in.clen == packetClen && packetCmd == in.cmd && packetCfixed == in.cfixed);
         --packetClen;
         if (packetCfixed)
            assume(packetContig == in.contig && packetWrap == in.wrap
                  && packetCons == in.cons && packetPlen == in.plen);
      }
      else {
         packetClen = in.clen;
         ++packetClen;
         packetCmd = in.cmd;
         packetCfixed = in.cfixed;
      };
      --packetClen;
      packetAddress = in.address;
      packetPlen = in.plen;
      packetContig = in.contig;
      packetWrap = in.wrap;
      assume(!packetWrap || (packetContig && ((packetPlen-1 & packetPlen) == 0)));
      packetCons = in.cons;
      plPendingPackets.add(in);
      if (packetCmd == 3) { // Locked read
         if (packetContig)
            laLockedAddresses.add(in.srcid, packetAddress, packetPlen);
         else
            laLockedAddresses.add(in.srcid, packetAddress);
      };
   }
   else {
      assume(packetClen == in.clen && packetCmd == in.cmd && packetPlen == in.plen);
      if (packetCons) {
         assume(packetCfixed == in.cfixed && packetAddress == in.address
            && packetContig == in.contig && packetWrap == in.wrap && packetCons == in.cons);
      }
      else if (packetContig) {
         packetAddress += vci_param::B; // cell_size()
         if (packetWrap && (uRequestCells > packetPlen))
            packetAddress -= packetPlen*vci_param::B;
         assume(packetAddress == in.address);
      };
   };
   ++uRequestCells;
   if (in.eop) {
      assume(!packetPlen || packetPlen == uRequestCells);
      uRequestCells = 0;
      packetAddress = 0;
   };
}

template <typename vci_param>
void
AdvancedVciFilter<vci_param>::acquireResponseCell() {
   if (uResponseCells == 0) {
      assume(plPendingPackets.count() > 0);
      {  Packet* pPacket = plPendingPackets.remove(out);
         assume(pPacket);
         if (pPacket->cmd == 2) { // Write
            if (pPacket->contig)
               laLockedAddresses.remove(*this, out.rsrcid, pPacket->address, pPacket->plen);
            else
               laLockedAddresses.remove(*this, out.rsrcid, pPacket->address);
         };
         if (pPacket) delete pPacket;
      };
   };
   ++uResponseCells;
   if (out.reop)
      uResponseCells = 0;
}

}} // end of namespace soclib::caba

#endif // SOCLIB_CABA_PVDC_ADVANCED_FILTERTEMPLATE

