/////////////////////////////////////////////////////////////////////////////////
// File : VciXcache.txt
//
// Copyright : UPMC/LIP6
// Date : 21/01/2008
// Authors : Alain Greiner, Francois Pecheux
/////////////////////////////////////////////////////////////////////////////////

template<typename iss_t, typename vci_param>
class VciXcache<iss_t> : tlmt::BaseModule {

public :

/////// ports ///////
VciInitiator<vci_param>  p_vci ;
SynchroInPort  * p_irq ;

/////// constructor /////
VciXcache (sc_module_name  name,
          uint32_t  initiatorIndex,
          uint32_t  processorIdent,
          uint32_t  lookahead,
          uint32_t  dcache_nlines,
          uint32_t  dcache_nwords,
          uint32_t  icache_nlines,
          uint32_t  icache_nwords)
    BaseModule(name),
    m_iss(processorIdent),
    m_time( 0 ),
    m_dcache( dcache_nwords, dcache_nlines ),
    m_icache( icache_nwords, icache_nlines ),
    m_wbuf( 32 )
    {
    p_vci("vci", this, &VciXcache::rspReceived, &m_time) ;
    for (uint32_t i = 0 ; i < iss_t::n_irq ; i++) { 
        new(&p_irq[i])SynchroInPort ("irq", i, this, &VciXcache::irqReceived) ; 
        }
    m_counter = 0 ;
    m_lookahead = lookahead ;
    m_write_error = false ;
    m_read_error = false ;
    m_vci_pending = false ;
    m_cmd.srcid = initiatorIndex ;
    m_cmd.contig = true ;
    m_cmdtrdid = 0 ;
    m_cmd.pktid = 0 ;
    SC_THREAD(execLoop) ;
    } // end constructor

////////////
void reset()
    {
    m_iss.reset() ;
    m_dcache.reset() ;
    m_icache.reset() ;
    m_wbuf.reset() ;
    m_write_error = false ;
    m_read_error = false ;
    m_vci_pending = false ; 
    }

private :

////  member variables ///////
tlmt_time       m_time ;
sc_event        m_rsp_received ;
iss_t           m_iss ;
genericCache    m_dcache ;
genericCache    m_icache ;
writeBuffer     m_wbuf ; 
segmentTable    m_segtab ;
bool            m_write_error ;
bool            m_read_error ;
bool            m_vci_pending ;
uint32_t        m_rsptime ;
uint32_t        m_lookahead ;
uint32_t        m_counter ;
bool            m_irqpending[iss_t::n_irq];
uint32_t        m_irqtime[iss_t::n_irq] ;
vci_cmd_t       m_cmd ;
uint32_t        m_read_buffer[32] ;
uint32_t        m_write_buffer[32] ;

///////////////
void execLoop()
    {
    icache_request_t  icache_req ;		// The Icache request 
    dcache_request_t  dcache_req ;		// The Dcache request
    xcache_response_t  xcache_rsp ;	        // The Xcache response
    uint32_t  irqword ;
    while(1) {     /////////// execute one cycle /////
        m_time.addTime( 1 ) ;  // increment local time 
        if (m_iss.isBusy() {
            m_iss.nullStep() ;
        } else {
            /////////// cache access /////////////////////
            m_iss.getInstructionRequest(icache_req.valid,
                          icache_req.type,
                          icache_req.address) ;
            m_iss.getDataRequest(dcache_req.valid, 
                          dcache_req.type,
                          dcache_req.address, 
                          dcache_req.wdata) 
            xcacheAccess(&icache_req, &dcache_req, &xcache_rsp) ;
            if ( icache_req.valid ) m_iss.setInstruction(xcache_rsp.iber, xcache_rsp.instruction) ;
            if ( dcache_req.valid ) m_iss.setDataResponse(xcache_rsp.dber, xcache_rsp.rdata) ;
            //////// handling interrupts /////////////////
            irqword = 0 ;
            for ( size_t i = 0 ; i < iss_t ::n_irq ; i++) {
                if( m_irqpending[i] && m_irqtime[i] <= get_time()) irqword  |= (1<<i);
               }
            m_iss.setIrq(irqword) ;
            ///////// handling asynchronous bus error //////
            if ( m_write_error ) {
                setWriteBerr() ;
                m_write_error = false ;
            } 	
            m_iss.step() ;
        } // end step
        ////////// lookahead management //////////
        m_counter++ ;
        if (m_counter >= m_lookahead) {
            m_counter = 0 ;
             wait(SC_ZERO_TIME) ;
        } // end if lookahead
        } // end while
    } // end execLoop()		
		
/////////////////////////////////////////
void cacheAccess(icache_request_t ireq, 
                dcache_request_t dreq, 
                xcache_response_t xrsp)
    {
    // handling write buffer requests
    if ( !m_wbuf.empty() ) {
        if ( !dreq.valid ||
             !( (dreq.type == WW) || (dreq.type == WH) || (dreq.type == WB) ) ||
             !( m_wbuf.endBurst( dreq.address ) ) ) {  // write burst can be send
            uint32_t address = m_wbuf.getAddress() ;
            uint32_t type = m_wbuf.getType() ;
            if    ( m_wbuf.getType() == WW ) m_cmd.be = 0xF ;
            elsif ( m_wbuf.getType() == WH ) m_cmd.be = 0x3 << address & 0x2 ;
            elsif ( m_wbuf.getType() == WB ) m_cmd.be = 0x1 << address & 0x3 ;
            m_cmd.address = address ;
            m_cmd.cmd = CMD_WRITE ;
            m_cmd.buf = m_write_buffer ;
            for ( uint32_t i = 0 , bool last = false ; last == false ; i++ ) 
                last = m_wbuf.lastWrite() ;  
                m_write_buffer[i] = m_wbuf.popData() ;
                }
            m_cmd.length = i+1 ;
            p_vci.send( m_cmd, m_time.getTime() ) ;
            m_vci_pending = true ;
        }  // end if write burst 
    } // end if m_wbuf not empty

    // handling the data request
    if (dreq.valid ) {  
        if ( m_vci_running ) {  // waiting the completion of the current VCI transaction
            wait( m_rsp_received ) ;
            m_time.updateTime( m_rsptime ) ;
        }
        switch ( dreq.type ) {
        case RW, RH, RB :   
            if ( m_segtab.uncached( dreq.address ) ) {     // read data uncached (blocking)
                m_cmd.cmd = CMD_READ ;
                if    ( dreq.type == RW ) m_cmd.be = 0xF ;
                elsif ( dreq.type == RH ) m_cmd.be = 0x3 << dreq.address & 0x2 ;
                elsif ( dreq.type == RB ) m_cmd.be = 0x1 << dreq.address & 0x3 ;
                m_cmd.address = dreq.address ;
                m_cmd.length = 1 ;
                m_cmd.buf = m_read_buffer ;
                p_vci.send( m_cmd, m_time.getTime() ) ;
                m_vci_pending = true ;
                wait( m_rsp_received ) ;
                m_time.updateTime( m_rsptime ) ;
                xrsp.dber = m_read_error ;
                xrsp.rdata = m_read_buffer[0] ;

            } else if ( m_dcache.miss( dreq.address ) ) {  // read data miss (blocking)
                m_cmd.address = dreq.address ;
                m_cmd.cmd = CMD_READ ;
                m_cmd.length = dcache.m_cmdwords ;
                m_cmd.buf = m_read_buffer ;
                m_cmd.be = 0xF ;
                p_vci.send( m_cmd, m_time.getTime() ) ;
                m_vci_pending = true ;
                wait( m_rsp_received ) ;
                m_time.updateTime( m_rsptime ) ;
                m_dcache.update( dreq.address, m_read_buffer ) ;
                xrsp.dber = m_read_error ;
                xrsp.rdata = m_dcache.read( dreq.address ) ;
            } else {                                    // read data hit (non blocking)
                xrsp.dber = false ;
                xrsp.rdata = m_dcache.read( dreq.address ) ;
        break;      
        case WW, WH, WB :                              // write request (non blocking)
            if ( !m_dcache.miss ( dreq.address ) ) {
                m_dcache.write ( dreq.address, dreq.type, dreq.wdata ) ;
            }
            m_wbuf.push( dreq.address, dreq.type , dreq.wdata ) ;
            xrsp.dber = false ;
            xrsp.rdata = 0 ;
        break;
        case RZ :
            dcache.inval( dreq.address ) ;
            xrsp.dber = false ;
            xrsp.rdata = 0 ;
        break;
        case LL :                                        // linked load (blocking)
            m_cmd.address = dreq.address ;
            m_cmd.cmd = CMD_READ_LOCKED ;
            m_cmd.length = 1 ;
            m_cmd.buf = m_read_buffer ;
            m_cmd.be = 0xF ;
            p_vci.send( m_cmd, m_time.getTime() ) ;
            m_vci_pending = true ;
            wait( m_rsp_received ) ;
            m_time.updateTime( m_rsptime ) ;
            xrsp.dber = m_read_error ;
            xrsp.rdata = m_read_buffer[0] ;
        break;
        case SC :                                       // store conditional (blocking) 
            m_cmd.address = dreq.address ;
            m_cmd.cmd = CMD_WRITE_COND ;
            m_cmd.length = 1 ;
            m_cmd.buf = m_write_buffer ;
            m_write_buffer[0] = dreq.wdata ;
            m_cmd.be = 0xF ;
            p_vci.send( m_cmd, m_time.getTime() ) ;
            m_vci_pending = true ;
            wait( m_rsp_received ) ;
            m_time.updateTime( m_rsptime ) ;
            xrsp.dber = m_read_error ;
            xrsp.rdata = m_write_buffer[0] ;
        break;
        } // end switch
    } // endif dreq

    // handling the instruction request
    if ( ireq.valid ) { 
        if ( m_vci_running ) { // waiting the completion of the current VCI transaction
            wait( m_rsp_received ) ;
           nnn m_time.updateTime( m_rsptime ) ;
        }
        if ( m_icache.miss( ireq.address ) {       // fetch instruction miss
            m_cmd.address = ireq.address ;
            m_cmd.cmd = CMD_READ ;
            m_cmd.length = icache.m_words ;
            m_cmd.buf = m_read_buffer ;
            m_cmd.be = 0xF ;
            p_vci.send( m_cmd, m_time.getTime() ) ;
            m_vci_pending = true ;
            wait( m_rsp_received ) ;
            m_time.updateTime( m_rsptime ) ;
            m_icache.update( dreq.address, m_read_buffer ) ;
            xrsp.iber = m_read_error ;
            xrsp.ins = m_icache.read( ireq.address ) ;
        } else {                                   // fetch instruction hit
            xrsp.iber = false ;
            xrsp.ins = m_icache.read( ireq.address ) ;
        }
    } // endif ireq
    } // end cacheAccess()

/////////////////////////////////////////////////////
void  rspReceived(vci_rsp_t rsp, uint32_t time)
    {
    if ( rsp.cmd == CMD_WRITE )  m_write_error = ( rsp.error != 0 ) ;
    if ( rsp.cmd == CMD_READ )   m_read_error = (rsp.error != 0 ) ;
    m_rsptime = time + rsp.length ;
    m_vci_pending = false ; 
    notify( m_rsp_received ) ;
    } // end rspReceived()

////////////////////////////////////////////////////////////
void  irqReceived(bool val, uint32_t time, size_t index)
    {
    m_irqpending[index] = val ;
    m_irqtime[p_irq[index] = time ;
    } // end irqReceived()
} // end class VciXcache

////////////////////////////////////////////////////////////
//  Modle de cache gŽnŽrique
////////////////////////////////////////////////////////////

class genericCache {

typedef uint32_t addr_t ;
typedef uint32_t data_t ;

data_t**                       m_data ;
addr_t*                        m_tag ;
bool*                          m_val ;
AddressMaskingTable<uint32_t>  m_x ;
AddressMaskingTable<uint32_t>  m_y ;
AddressMaskingTable<uint32_t>  m_z ;

///////// Constructor ////////////////
genericCache( int nlines, int nwords ) :
    m_x( log2(nwords), 2 ),
    m_y( log2(nlines), 2+log2(nwords) ),
    m_z( 32-log2(nwords)-log2(nlines)-2, log2(nwords)+log2(nlines)+2 )
    {
    m_data = new data_t*[nlines] ;
    for ( size_t i = 0 ; i < nlines ; i++ ) m_data[i] = new data_t[nwords] ;
    m_tag = new addr_t[nlines] ;
    m_val = new bool[nlines] ;
    m_words = nwords ;
    m_lines = nlines ;
    } 

//////////////////////////////
inline void reset( )
    {
    for ( size_t i = 0 ; i < m_lines ; i++ ) m_val[i] = false ;
    }

//////////////////////////////
inline bool miss( addr_t ad )
    {
    int y = m_y[ad] ;
    int z = m_z[ad] ;
    return !( ( m_tag[y] == z ) && m_val[y] ) ;
    }

///////////////////////////////
inline data_t read( addr_t ad )
    {
    int y = m_y[ad] ;
    int x = m_x[ad] ;
    return m_data[y][x] ;
    } 
	
/////////////////////////////////////////
inline void write( addr_t ad, data_t dt )
    {
    int y = m_y[ad] ;
    int x = m_x[ad] ;
    m_data[y][x] = dt ;
    } 

//////////////////////////////
inline void inval( addr_t ad )
    {
    int y = m_y[ad] ;
    val[y] = false ;
    }

/////////////////////////////////////////////
inline void update( addr_t ad, data_t *buf )
    {
    int y = m_y[ad] ;
    int z = m_z[ad] ;
    val[y] = true ;
    tag[y] = z ;
    for ( size_t i = 0 ; i < m_words ; i++ ) data[y][i] = buf[i] ;
    }
} // end class genericCache

///////////////////////////////////////////
//  Write Buffer
///////////////////////////////////////////

typedef uint32_t data_t ;
typedef uint32_t addr_t ;
typedef uint32_t addr_t ;

class writeBuffer {

//////// constructor ////////////
writeBuffer( int depth )
    {
    m_data = new data_t[depth] ;
    m_addr = new addr_t[depth] ;
    m_type = new type_t[depth]
    m_depth = depth ;
    m_items = 0 ;
    m_ptw = 0 ;
    m_ptr = 0 ;
    }

data_t*    m_data ;
addr_t*    m_addr ;
type_t*    m_type ;
int        m_depth ;
int        m_ptr ;
int        m_ptw ;
int        m_items ;

/////////////////////
inline void reset( )
    {
    m_items = 0 ;
    m_ptw = 0 ;
    m_ptr = 0 ;
    }

///////////////////////////////////////////////////
inline void push( addr_t ad, type_t ty, data_t dt )
    {
    assert( m_items < m_depth ) ;
    m_data[m_ptw] = dt ;
    m_addr[m_ptw] = ad & ~0X3 ;
    m_type[m_ptw] = ty ;
    m_items++ ;
    m_ptw++ ;
    if ( m_ptw == m_depth ) m_ptw = 0 ;
    } 

/////////////////////////
inline data_t popData( )
    {
    assert( m_items > 0 ) ;
    data_t dt = m_data[m_ptr] ;
    m_items-- ;
    m_ptr++ ;
    if ( m_ptr == m_depth) m_ptr = 0 ;
    return dt ;
    }

///////////////////////////
inline addr_t getAddress( )
    {
    return m_addr[m_ptr] ;
    }

///////////////////////////
inline type_t getType( )
    {
    return m_type[m_ptr] ;
    }

////////////////////
inline bool empty( )
    {
    return (m_items == 0) ;
    }

//////////////////////////////////
inline bool endBurst( addr_t ad )
    {
    int ptlast = m_ptr + m_items - 1 ;
    if ( ptlast >= m_items ) ptlast = ptlast - m_items ;
    return ( ( ad & ~0X3 )  + 4 != m_addr[ptlast] ) ;
    }

///////////////////////
inline bool lastWrite()
    {
    int ptnext = m_ptr + 1 ;
    if ( ptnext == m_depth ) ptnext = 0 ;
    return ( ( m_addr[ptrnext] == ( m_addr[m_ptr] + 4 ) ) && ( m_items > 1 ) ) ;
    }

} // end class writeBuffer	
	
