
# SOCLIB_GPL_HEADER_BEGIN
# 
# This file is part of SoCLib, GNU GPLv2.
# 
# SoCLib is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
# 
# SoCLib is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with SoCLib; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.
# 
# SOCLIB_GPL_HEADER_END
# 
# Copyright (c) UPMC, Lip6, SoC
#         Nicolas Pouillon <nipo@ssji.net>, 2007
# 
# Maintainers: group:toolmakers

import sys
import os, os.path
from soclib_cc.config import config
from bblock import bblockize, BBlock, filenames
from action import Noop, ActionFailed, Action

__id__ = "$Id$"
__version__ = "$Revision$"

def cr(x):
    return not isinstance(x, Noop)

class Again(Exception):
    pass

class ToDo:
    def __init__(self, *dests):
        self.has_blob = False
        self.dests = []
        self.add(*dests)
        self.prepared = False
        d = config.reposFile('')
        if not os.path.isdir(d):
            os.makedirs(d)
        self.max_actions = config.toolchain.max_processes

    def genMakefile(self):
        from datetime import datetime
        self.prepare()

        cleans = ''
        targets = ''
        
        for t in self.todo:
            cleans += t.genMakefileCleanCommands()
            targets += t.genMakefileTarget()
        default_targets = ' '.join(map(str, self.todo[-1].dests))
        return '''
# Makefile generated by soclib-cc on %(date)s.
# Dont modify directly, and dont commit in soclib repository

# You may try:
#  make -f <makefile>
#  make -f <makefile> clean
# or
#  make -f <makefile> VERBOSE=1
#  make -f <makefile> VERBOSE=1 clean

# Parallel build (with -j x) may even work.

# This is not the prefered way to build a soclib platform, mainly
# because it does not handle dependency tracking correctly. This
# feature is left out to the the hardy reader.

# Maintainers: notme

ECOLON=\:
COLON=:
.SECONDEXPANSION:
ifeq ($(VERBOSE),)
CMDPFX=@
else
CMDPFX=
endif

all: %(default_targets)s

clean:
%(cleans)s

%(targets)s
'''%dict(
            default_targets = default_targets,
            cleans = cleans,
            targets = targets,
            date = str(datetime.now()),
            )

    def add(self, *dests):
        self.dests += bblockize(dests)
        for d in self.dests:
            self.has_blob |= d.is_blob
    def _getall_bbs(self, dests):
        dest_bb_list = set(dests)
        viewed_bb_list = set(dests)
        todo_generator_list = set()

        while dest_bb_list:
            bb = dest_bb_list.pop()
            viewed_bb_list.add(bb)

            gen = bb.generator
            gen.prepare()
            dest_bb_list |= set(gen.getDepends())
            todo_generator_list.add(gen)
#            print gen
            
            dest_bb_list -= viewed_bb_list

        todo_generator_list = filter(cr, todo_generator_list)
        return todo_generator_list, viewed_bb_list
    
    def prepare(self):
        if self.prepared:
            return
        
        try:
            todo, bblocks = self._getall_bbs(self.dests)
        except ActionFailed, e:
            self.handle_failed_action(e)

#         print '---'
#         for a in todo:
#             print a
#             #a.prepare()
#         print '---'
# 
#         print '=-='
#         print filenames(self.dests)
#         print '=-='

        for b in bblocks:
            b.generator.prepare()
        for b in bblocks:
            b.prepare()

        bblocks = list(bblocks)
        bblocks.sort()

        self.todo = []
        viewed = set()
        for b in bblocks:
            g = b.generator
            if isinstance(g, Noop) or g in viewed:
                continue
            self.todo.append(g)
            viewed.add(g)
        if set(self.todo) < set(todo):
            print 'Lost generators in battle:'
            for i in set(todo) - set(self.todo):
                for d in i.dests:
                    print d in self.dests, d.generator.__class__, d
            raise RuntimeError()

        self.todo.reverse()
        self.prepared = True

#        for i, g in enumerate(self.todo):
#            print i, filenames(g.dests), filenames(g.sources)
        
    def clean(self):
        self.prepare()
        for i in xrange(len(self.todo)-1,-1,-1):
            todo = self.todo[i]
            todo.clean()
    def handle_failed_action(self, e):
        print "soclib-cc: *** Action failed with return value `%s'. Stop."%e.rval
        if self.has_blob:
            print '***********************************************'
            print '***********************************************'
            print '**** WARNING, YOU USED BINARY-ONLY MODULES ****'
            print '***********************************************'
            print '***********************************************'
            print 'If you compilation failed because of linkage, this is most'
            print 'likely a mismatch between expected libraries from a binary'
            print 'only module and your system libraries (libstdc++, SystemC, ...)'
            print
            print "\x1b[91mPlease don't report any error about binary modules"
            print "to SoCLib-CC maintainers, they'll ignore your requests.\x1b[m"
            print 
        if config.verbose:
            print "soclib-cc: Failed action: `%s'"%e.action
        while Action.pending_action_count():
            print "soclib-cc: Waiting for unfinished jobs"
            Action.wait()
    def wait(self):
#        try:
            Action.wait()
#        except ActionFailed, e:
#            self.handle_failed_action(e)
#        self.progressBar()
    def process(self):
        import sys
        self.prepare()
        if config.verbose:
            print 'Would do:'
            print "="*80
            print "="*80
            for i, g in enumerate(self.todo):
                print i, filenames(g.dests), filenames(g.sources)
            print "="*80
            print "="*80
        l = len(self.todo)
        for pi in self.todo:
            pi.todoRehash()
        while True:
            try:
                left = self.todo[:]
                left.reverse()
                while left:
                    todo = left.pop()
                    while not todo.canBeProcessed() and Action.pending_action_count():
                        self.wait()
                    if not todo.canBeProcessed():
                        todo.dumpAbsentPrerequisites()
                        raise ActionFailed(1, "Prerequisites not found")
#                       self.clean()
#                       raise Again()
                    if todo.mustBeProcessed():
                        todo.process()
                    else:
                        if config.verbose:
                            print 'No need to redo', todo, len(left)
                        continue
                    self.progressBar()
                    if Action.pending_action_count() >= self.max_actions:
                        self.wait()
                while Action.pending_action_count():
                    self.wait()
            except OSError, e:
                if hasattr(e, 'child_traceback'):
                    print e.child_traceback
                raise
            except Again:
                continue
            break
        self.progressBar()
    def progressBar(self):
        if not config.progress_bar:
            return
        pb = ""
        for pi in self.todo:
            pb += pi.todoInfo()
        sys.stdout.write('\r['+pb+']')
        sys.stdout.write(' %d left '%(pb.count(' ')))
        sys.stdout.flush()
